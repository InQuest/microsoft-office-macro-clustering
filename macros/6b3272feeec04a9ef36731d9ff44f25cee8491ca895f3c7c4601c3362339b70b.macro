Attribute VB_Name = "CheckIt"

Public Sub Main()
WordBasic.WW7_EditAutoText Name:="Checked Box", Context:=1, InsertAs:=0, Insert:=1
End Sub
Attribute VB_Name = "ClassAppEvents"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents app As Application

Private Sub app_DocumentChange()
    On Error Resume Next
    
    CloseBln
    
    OpenBln
    Set objDocBln = ActiveDocument
FatalError:
    Err.Clear
End Sub

Private Sub CloseBln()
Dim strVal As String
    On Error GoTo FatalErrorClose
    strVal = ""
    
    'if old doc's bln was being displayed, then close it
    strVal = objDocBln.Variables(strPOST_WIZ_BLN).Value
    If strVal = "1" Then
        If fPostWizBlnOpen Then
            objPostWizBln.Close
            fPostWizBlnOpen = False
        End If
    End If
FatalErrorClose:
    Err.Clear
End Sub

Private Sub OpenBln()
Dim strVal As String

    On Error GoTo FatalErrorOpen
    strVal = ""
    strVal = ActiveDocument.Variables(strPOST_WIZ_BLN).Value

    'check to see if bln should be displayed for new doc.
    If (strVal = "1") Then
        objPostWizBln.Show
        fPostWizBlnOpen = True
    End If
    
FatalErrorOpen:
    Err.Clear
End Sub
Attribute VB_Name = "Common"
' --------------------------------------------------------------------------------------
' WORD 97 WIZARD
' Common VBA Module
' --------------------------------------------------------------------------------------

Option Explicit
'jeb debug
Public Const fPERF_TESTING As Boolean = True    ' Logs performance times to c:\Wizard.log
Public strTestDate As String
' --------------------------------------------------------------------------------------
' CONSTANT DECLARATIONS

' Note use of trailing spaces and punctuation...

' Banter strings
Public Const strSTARTING        As String = "Der "
Public Const strSTARTING2       As String = " wird geladen..."
Public Const strAPPLYING        As String = "Formatvorlagen werden kopiert..."
Public Const strCREATING_DOC    As String = "Dokument wird erstellt..."
Public Const strSAVE_SETTINGS   As String = "Einstellungen werden gespeichert..."
Public Const strRST_SETTINGS    As String = "Einstellungen werden wiederhergestellt..."
Public Const strUPDATING_STYLE  As String = "Formatvorlagen werden kopiert..."

' Error messages
Public Const strERR_BAD_DOC         As String = "Der Assistent kann nicht im aktiven Dokument verwendet werden. Um den Assistenten zu verwenden, w|fffd|hlen Sie ""Neu"" im Men|fffd| ""Datei"" und w|fffd|hlen Sie den "
Public Const strERR_BAD_DOC2        As String = " aus."
Public Const strERR_INTERNAL        As String = "Der Assistent kann nicht fortfahren, da ein Fehler aufgetreten ist."
Public Const strERR_WIZ_NOT_FOUND   As String = "Der Assistent konnte nicht im Benutzer-Vorlagen-Pfad gefunden werden."
Public Const strERR_STYLE_NOT_FOUND As String = "Der Assistent konnte die ben|fffd|tigte Datei "
Public Const strERR_STYLE_NOT_FOUND2 As String = " nicht finden. Diese Datei wird ben|fffd|tigt, um das Dokument zu formatieren. Falls die Datei nicht installiert ist, f|fffd|hren Sie bitte das Setup erneut durch, und installieren Sie die Datei."
Public Const strERR_ADDR_BOOK       As String = "Fehler beim Einf|fffd|gen eines Namens aus einem Adre|fffd|buch."
Public Const strERR_SEND_FAX        As String = "Der Assistent konnte dieses Dokument nicht per Fax versenden."
Public Const strERR_SEND_MAIL       As String = "Der Assistent konnte dieses Dokument nicht per E-Mail versenden."
Public Const strERR_AUTOTEXT_NOT_FOUND As String = "Word konnte keinen AutoText aus dem Assistenten einf|fffd|gen. Bitte f|fffd|hren Sie das Setup-Programm erneut aus und installieren Sie diesen Assistenten neu."
Public Const strERR_INIT_FORM       As String = "Word konnte den Eingabedialog des Assistenten nicht anzeigen. Bitte starten Sie den Assistenten erneut."
Public Const strERR_INIT_CALL_BACK  As String = "Word konnte die Auswahloptionen zum Ende des Assistenten nicht anzeigen. Bitte starten Sie den Assistenten erneut, um die Auswahlm|fffd|glichkeiten zu sehen."

' Misc strings
Public Const strWIZ As String = ".wiz"  'common extension to a wizard file
Public Const strDOT As String = ".dot"  'extension to a template file

'the setting in which this wizard has been saved. If the wizard is saved with A4 settings then
'this constant should be set to A4
Public Const strWIZ_SAVED_AS As String = "A4"

'the settings key for page size
Public Const strREG_PAGE_SIZE As String = "PageSize"
'to check if it is A4 and change the pagesize if the key's value is this string
Public Const strA4_SETTING As String = "A4"
' --------------------------------------------------------------------------------------
' ************     DO NOT LOCALIZE ANY CODE BEYOND THIS POINT  *************************
' --------------------------------------------------------------------------------------

'registry key under which to store individual wizard preference settings
Public Const strREG_SETTINGS_BASE_KEY As String = "HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Word\Wizards\"

Public Const strSPACE       As String = " "
Public Const strCOMMA       As String = ","
Public Const strSHP_MAP     As String = "shpMap"  'prefix to the names of the shapes in the navigation chart/map
Public Const strLBL_MAP     As String = "lblMap"  'prefix to the names of the labels in the navigation chart/map
Public Const strREG_ASSISTANT_HELP As String = "Assistant Help" 'registry entry to store local state of Assistant
                                                                'for this wizard
Public Const strREG_ASSISTANT_TIME_STAMP As String = "Time Stamp" 'registry to store the time stamp when the
                                                                  'local state of the wizard changed.

'COLOR constants used
Public Const COLOR_DISABLED As Long = &H404040  'used for disabled panel's label and shape
Public Const COLOR_DARKGREY As Long = &H808080  'used for visited panel's label and shape
Public Const COLOR_LIGHTGREY As Long = &HC0C0C0 'used for unvisited panel's label and shape
Public Const COLOR_RED      As Long = vbRed
Public Const COLOR_GREEN    As Long = vbGreen
Public Const COLOR_WHITE    As Long = vbWhite


' --------------------------------------------------------------------------------------
' VARIABLE DECLARATIONS

' Wizard Names And FileNames
Public strWizName As String
Public strWizLongName As String
Public strWizShortName As String

Public fSettingsRestored As Boolean
Public fSettingsSaved As Boolean

' Application Environment
Public objActiveRange   As Range     'current range
Public objWizTemplate   As Template  'doc's template i.e the wizard
Public iAlertsLevel      As Integer   'stores the initial alerts level

' Variables to store some environment values
Public strPathSeparator As String   ' Directory separator in a path
Public strTemplatePath As String    ' Path of the the wizard and corresponding templates

'current panel of the multipage control in the dialog
Public iCurrentPanel As Integer

' Registry location key
Public strRegSettingsKey As String

' Assistant
Public objAssistantBalloon  As Balloon  'help balloon displayed for each panel
Public fBalloonVisible      As Boolean  'true if the above balloon is visible
Public iLocalState          As Integer  'Local State of Assistant for passing to Office
Public lAssistantId         As Long     'assistant id obtained from StartWizard call
Public fExitTglEvent        As Boolean  'this is set to True, if we don't want the click
                                        'event for the toggle buttonto be executed when
                                        'we change its value

Public fWizardCallBack      As Boolean  'we set it to True in FReenterWizardPanel
                                        'since it is used only in JumpToPanel
                                        'to disable jumping to otherpanels, by clicking
                                        'on the shapes
Public fInitialAssistantState As Boolean  ' to go back to after exiting wizard
Public fAsstHelp As Boolean

'if the activedocument's papersize was changed then one of the two following
'variables will be set according to the paper size that is being set.
Public fChangeToA4 As Boolean
Public fChangeToLetter As Boolean

'Post wizard balloon options.
Public objPostWizBln As Balloon
Public objDocBln As Document
Public clsBln As New ClassAppEvents
Public fBlnInitialized As Boolean
Public fPostWizBlnOpen As Boolean

'variables storing the rectangle of the form to be avoided
'by the asst. and balloon
Public lFormTop As Long, lFormHeight As Long
Public lFormLeft As Long, lFormWidth As Long

' Wizard dialog form
Public formWizard As formWizDlg 'New formWizDlg

'--------------------------- perf vars.
Public xxStartTime As Single
Public xxStartWizard As Single
Public xxInitWizardName As Single
Public xxStatusBar As Single
Public xxSetWizardEnvironment As Single
Public xxInitDocTemplate As Single
Public xxStrWizardPath As Single
Public xxInitDoc As Single
Public xxInitWizard As Single
Public xxStatusBar2 As Single
Public xxInitWizardAssistant As Single
Public xxWizardShow As Single
Public xx As String
Public xxInitWizard0 As Single
Public xxInitWizard1 As Single
Public xxInitWizard2 As Single
Public xxInitWizard3 As Single
Public xxInitWizard4 As Single
Public xxInitWizard5 As Single
Public xxInitWizard6 As Single


' General Purpose Utilities for Starting, Saving, and Restoring Wizards
' --------------------------------------------------------------------------------------


Public Sub StartWizard()
strTestDate = Now
xxStartWizard = Timer
    On Error GoTo FatalError
  
    Application.ScreenUpdating = False
    
    ' Init Global Var
    fWizardCallBack = False
    fExitTglEvent = False
    fSettingsRestored = False
    fSettingsSaved = False
    lAssistantId = 0
  
    ' Identify Wizard
xxInitWizardName = Timer
    InitWizardName (True)
    
    ' We're busy now
xxStatusBar = Timer
    StatusBar = strSTARTING & strWizName & strSTARTING2
    
xxSetWizardEnvironment = Timer
    SetWizardEnvironment

    ' Locate the wizard template
xxInitDocTemplate = Timer
    InitDocTemplate
xxStrWizardPath = Timer
    strTemplatePath = StrWizardPath

    ' Initialize the new document
xxInitDoc = Timer
    InitDoc
    
    ' Initialize form
xxInitWizard = Timer
    InitWizard (True)
    
    'remove any text which might written for indicating progress
xxStatusBar2 = Timer
    StatusBar = ""
    
    ' Connect to the Assistant
xxInitWizardAssistant = Timer
    InitWizardAssistant
    
    ' Bring up dialog
    System.Cursor = wdCursorNormal
xxWizardShow = Timer

If fPERF_TESTING Then
On Error Resume Next
Open "\Wizard.log" For Append As 7
Write #7, "Init", strWizShortName, strTestDate, Format(xxStartWizard - xxStartTime, "0.00"), "Load Common Module"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizardName - xxStartWizard, "0.00"), "3 param inits"
Write #7, "Init", strWizShortName, strTestDate, Format(xxStatusBar - xxInitWizardName, "0.00"), "3 string var inits"
Write #7, "Init", strWizShortName, strTestDate, Format(xxSetWizardEnvironment - xxStatusBar, "0.00"), "Starting... StatusBar"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitDocTemplate - xxSetWizardEnvironment, "0.00"), "Set Alerts/Cancel"
Write #7, "Init", strWizShortName, strTestDate, Format(xxStrWizardPath - xxInitDocTemplate, "0.00"), "Set objWizTemplate"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitDoc - xxStrWizardPath, "0.00"), "Get Wizard Path"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizard - xxInitDoc, "0.00"), "Set objActiveRange & objFps"
Write #7, "Init", strWizShortName, strTestDate, Format(xxStatusBar2 - xxInitWizard, "0.00"), "InitWizard"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizard1 - xxInitWizard0, "0.00"), "InitWiz: 3 params"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizard2 - xxInitWizard1, "0.00"), "InitWiz: Init Strings"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizard3 - xxInitWizard2, "0.00"), "InitWiz: Form Instance"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizard4 - xxInitWizard3, "0.00"), "InitWiz: Resume/CV frame"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizard5 - xxInitWizard4, "0.00"), "InitWiz: CV alternate labels"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizard6 - xxInitWizard5, "0.00"), "InitWiz: Read Registry Values"
Write #7, "Init", strWizShortName, strTestDate, Format(xxInitWizardAssistant - xxStatusBar2, "0.00"), "Clear StatusBar"
Write #7, "Init", strWizShortName, strTestDate, Format(xxWizardShow - xxInitWizardAssistant, "0.00"), "Init Assistant"
Write #7, "Init", strWizShortName, strTestDate, Format(xxWizardShow - xxStartWizard, "0.00"), "Total Init Time"
Write #7, "Init", strWizShortName, strTestDate, Format((xxWizardShow - xxStartWizard) - (xxStatusBar - xxInitWizardName), "0.00"), "Corrected Total Init Time"
Close #7
End If

    Application.ScreenUpdating = True
    
    formWizard.Show
    
    ResetWizardEnvironment (True)
    Exit Sub

FatalError:
    ReportError Err
End Sub  ' Main / StartWizard


Private Sub InitDocTemplate()
    ' Did user create a New Document or a New Template?
    On Error GoTo CreatingNewTemplate
    
    ' New Document
    Set objWizTemplate = ActiveDocument.AttachedTemplate
    Exit Sub

CreatingNewTemplate:
    ' New Template
    Set objWizTemplate = ActiveDocument
End Sub  ' InitDocTemplate


Private Function StrWizardPath() As String
    Dim strPath As String
    Dim strFileName As String
    Dim i As Integer
    Dim fFound As Boolean

    On Error GoTo FatalError
    
    fFound = True
    strPath = objWizTemplate.Path

    If (Len(strPath) = 0) Then
        ' New template based on Wizard
        ' Get location of templates - first look in UserTemplatesPath
        ' and then in Workgroup path

        i = 0
        fFound = False
        strPath = Application.Options.DefaultFilePath(wdUserTemplatesPath)
        
        While ((i < 2) And fFound = False)
            If (Len(strPath) <> 0) Then
                ' First try to find wizard with long filename
                WordBasic.FileFind SearchPath:=strPath, Name:=strWizLongName & strWIZ, SubDir:=1, MatchCase:=0
                If WordBasic.CountFoundFiles() = 0 Then
                    ' Try to find wizard with short filename
                    WordBasic.FileFind SearchPath:=strPath, Name:=strWizShortName & strWIZ, SubDir:=1, MatchCase:=0
                    If WordBasic.CountFoundFiles() <> 0 Then fFound = True
                Else
                    fFound = True
                End If
            End If
        
            i = i + 1
            strPath = Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath)
        Wend
        
        If (fFound) Then ' Wizard was found, so save path
            strFileName = WordBasic.[FoundFileName$](1)
            strPath = WordBasic.[FileNameInfo$](strFileName, 5)
        End If
    End If

    If (fFound) Then
        strPathSeparator = Application.PathSeparator
        If Right$(strPath, 1) <> strPathSeparator Then strPath = strPath & strPathSeparator
        StrWizardPath = strPath
        Exit Function
    End If

LWizardMissing:
    DisplayErrorMsg strERR_WIZ_NOT_FOUND
    
FatalError:
    ReportError Err
End Function ' StrWizardPath

'sets the wizard environment
Private Sub SetWizardEnvironment()
    System.Cursor = wdCursorWait
    'set alert level to none, so that Word/VBA dont display display any
    'error messages by themselves
    iAlertsLevel = Application.DisplayAlerts
    Application.DisplayAlerts = wdAlertsNone
    'Disable Cancel key, to prevent ESC key from interrupting the macro.
    'it will still dismiss the Form though
'arult:commented out for development debugging
'    Application.EnableCancelKey = wdCancelDisabled
End Sub

'resets the environment to what it was before the wizard was executed
Sub ResetWizardEnvironment(fDummy As Boolean)
    System.Cursor = wdCursorNormal
    'remove any text which might written for indicating progress
    StatusBar = ""
    Application.ScreenUpdating = True
    ActiveWindow.View.Type = wdPageView
    Application.DisplayAlerts = iAlertsLevel
'arult:disabled for debugging during development.
'    Application.EnableCancelKey = wdCancelInterrupt
End Sub

'returns the value stored in registry key strId
Public Function StrFetchPref(strId As String) As String
    On Error GoTo LReturnNull
    
    StrFetchPref = System.PrivateProfileString("", strRegSettingsKey, strId)
    Exit Function
LReturnNull:
    StrFetchPref = ""
End Function


'stores strValue in registry key strId
Public Sub StorePref(strId As String, strValue As String)
    Dim strTemp As String

    ' If string is empty, store "~" as placeholder
    If (Len(strValue) = 0) Then
        strTemp = "~"
    Else
        strTemp = strValue
    End If
    
    System.PrivateProfileString("", strRegSettingsKey, strId) = strTemp
End Sub


'returns the string stored in strId. If empty, returns strDefault
Public Function StrRestorePref(strId As String, strDefault As String) As String
    Dim strTemp As String

    strTemp = StrFetchPref(strId)
    ' If length is 0, it wasn't in regsistry, so use default value
    If Len(strTemp) = 0 Then
        strTemp = strDefault
    ' "~" is a placeholder to allow returning empty strings
    ElseIf strTemp = "~" Then
        strTemp = ""
    End If
    
    StrRestorePref = strTemp
End Function


' stores iVal in registry key strId as a string
Public Sub StoreValPref(strId As String, iVal As Integer)
    StorePref strId, CStr(iVal)
End Sub


'returns the value stored in the key strId
'if invalid, returns iDefault
Public Function FRestorePref(strId As String, fDefault As Boolean) As Boolean

    Dim strVal As String

    strVal = StrFetchPref(strId)
    If Len(strVal) = 0 Then
        FRestorePref = fDefault
    Else
        FRestorePref = Val(strVal)
    End If
End Function


'returns the value stored in the key strId
'if invalid, returns iDefault
Public Function IRestorePref(strId As String, iDefault As Integer) As Integer
    Dim strVal As String

    strVal = StrFetchPref(strId)
    If Len(strVal) = 0 Then
        IRestorePref = iDefault
    Else
        IRestorePref = Val(strVal)
    End If
End Function


'main error reporting routine called for fatal errors in the wizard
'SHOULD NOT BE CALLED FOR POST-WIZARD ERRORS
Public Sub ReportError(ByVal ErrorCode As ErrObject)
    Dim lErrorCode As Long
    Dim strErrorMsg As String
    
    lErrorCode = ErrorCode.Number
    strErrorMsg = ErrorCode.Description
    
    'The next statement seems to reset the ErrorCode object,
    'even though it is a ByVal argument
    On Error Resume Next
    
    ResetWizardEnvironment (True)
    
    If fBalloonVisible Then objAssistantBalloon.Close
    If lErrorCode Then DisplayErrorMsg strErrorMsg
    If lAssistantId Then Assistant.EndWizard lAssistantId, False '2nd parameter is fSuccess
    
    If (Not (formWizard Is Nothing)) Then
        formWizard.Hide
        Unload formWizard
        Set formWizard = Nothing
    End If
    
    'ReportError is not called in post-wizard option errors.
    'So, always closing the doc.
    ActiveDocument.Close wdDoNotSaveChanges 'ActiveDocument assumed to be set
    
    'terminate the wizard
    End

End Sub ' ReportError

'initialises the new doc. that is getting created
Private Sub InitDoc()
    Dim fBadDoc As Integer
    
    On Error GoTo FatalError
    
    ' Set to normal view for optimized performance
    'Application.ActiveWindow.ActivePane.View.Type = wdNormalView

    'chk if doc.path errors if path not present.
    fBadDoc = False
    If (Len(ActiveDocument.Path) <> 0) Then
        'doc has been saved before
        fBadDoc = True
    Else
        Set objActiveRange = ActiveDocument.Content
        'chk if range has anything other than a paragraph mark
        If (objActiveRange.End > objActiveRange.Start + 1) Then fBadDoc = True
    End If
        
    If (fBadDoc) Then
        DisplayErrorMsg strERR_BAD_DOC & strWizName & strERR_BAD_DOC2
        ResetWizardEnvironment (True)
        'terminate the wizard
        End
    End If
    
    objActiveRange.Collapse wdCollapseStart

    SetPageSize

    Exit Sub

FatalError:
    ReportError Err
End Sub  ' InitDoc


' --------------------------------------------------------------------------------------
' Assistant related functions
' --------------------------------------------------------------------------------------


'initialises the Assistant for the wizard
Private Sub InitWizardAssistant()
    Dim lPrivate As Long
    
    fBalloonVisible = False
    On Error GoTo FatalError
    
    ' Was Assistant visible, when wizard was started?
    fInitialAssistantState = Assistant.Visible
    
    ' What is the local state of Assistant for this wizard?
    'if user changed "Help for wizards" globally in the Assistant Options dlg,
    'Word will automatically update this to reflect the latest value.
    iLocalState = IRestorePref(strREG_ASSISTANT_HELP, msoWizardActInactive)
    
    'the form is shown centered on the app. -StartUpPosition = CenterOwner
    lFormHeight = formWizard.Height
    lFormWidth = formWizard.Width
    lFormTop = Application.Top + (Application.Height / 2) - (lFormHeight / 2)
    If (lFormTop < 0) Then lFormTop = 0
    lFormLeft = Application.Left + (Application.Width / 2) - (lFormWidth / 2)
    If (lFormLeft < 0) Then lFormLeft = 0

    lAssistantId = Assistant.StartWizard(iLocalState, "Common.fnHelpCallBack", lPrivate, _
                                    Top:=lFormTop, Left:=lFormLeft, _
                                    Bottom:=lFormTop + lFormHeight, _
                                    Right:=lFormLeft + lFormWidth)
    
    iLocalState = msoWizardActInactive
    If lAssistantId = 0 Then GoTo FatalError 'error with Assistant.Startwizard.
                                             'Assistant probably not installed
    
    ' Initialize Balloon
    Set objAssistantBalloon = Assistant.NewBalloon
    With objAssistantBalloon
        .Heading = strWizName
        .Mode = msoModeModeless
        .Button = msoButtonSetNone
        .Text = rgstrAssistantMsg(0)
    End With
    objAssistantBalloon.SetAvoidRectangle lFormLeft, lFormTop, lFormLeft + lFormWidth, lFormTop + lFormHeight
    If Assistant.BalloonError Then GoTo FatalError
    fAsstHelp = True
    Exit Sub
    
FatalError:
    fAsstHelp = False
    'since error occurred with assistant actions, let's disable Assistant button
    formWizard.tglAssistant.Enabled = False
    Err.Clear
End Sub

'this function called when user clicks on a button in the balloon put up by StartWizard or
'ActivateWizard.

'When user chooses "Help with this wizard" (in ActivateWizard) or "Please provide
'Help" (in StartWizard balloon), fnHelpCallBack is called with iHelp set to 1 and
'then again with iHelp set to 3. This is when we want to put up the Help balloon.
'That is when we also set iLocalState to True and depress the tglAssistant button
'if it is not already depressed

'If user chooses "Help with something else", or on call to ActivateWizard with localstate
'set to False, this function is called with iHelp set to 2.
'We undepress the tglAssistant button and close the balloon we put up (in case it is displayed).

'The click event for tglAssistant, calls ActivateWizard with Not (Local State).

'if we change the value of the tglAssistant button programmatically in this function as a result
'of the ActivateWizard call, it triggers the Click event for the tglAssistant. To avoid
'recursive calls we use the fExitTglEvent flag.

'fExitTglEvent should be set the exact number of times i.e. only when the click event will get
'triggered i.e. only when the value of the tglAssistant button is being changed.
'If it is set extra times for the sake of safety, the click event will end prematurely.

Public Sub fnHelpCallBack(iHelp As Integer, lPrivate As Long)
    Select Case iHelp
    'replace 1,2,3 with mso constants
        Case 1:


        Case msoWizardMsgLocalStateOff:
            iLocalState = msoWizardActInactive
            'user doesn't want help anymore
            'if balloon is up,then close it
            If fBalloonVisible Then
                objAssistantBalloon.Close
                fBalloonVisible = False
            End If
            
            If (formWizard.tglAssistant.Value) Then
                fExitTglEvent = True
                formWizard.tglAssistant.Value = False
            End If
        Case msoWizardMsgShowHelp:
            iLocalState = msoWizardActActive
                        
            If (Not (formWizard.tglAssistant.Value)) Then
                fExitTglEvent = True
                formWizard.tglAssistant.Value = True
            End If
            
            If fBalloonVisible Then Exit Sub 'help balloon already up (should not occur, though)
            
            If fAsstHelp Then 'if no error in building help balloon
                objAssistantBalloon.Text = rgstrAssistantMsg(iCurrentPanel)
                objAssistantBalloon.Show
                If Assistant.BalloonError = msoBalloonErrorNone Then _
                    fBalloonVisible = True
            End If

    End Select
End Sub

Public Sub RestoreAssistant(fDummy As Boolean)
    On Error Resume Next
    Assistant.Visible = fInitialAssistantState
    Err.Clear
End Sub  ' RestoreAssistant


'displays error message in a balloon if Assistant is visible
'else uses a Msgbox
Public Sub DisplayErrorMsg(strErrMsg As String)
    Dim objErrBalloon As Balloon

    On Error GoTo DisplayMsgBox
    
    If lAssistantId Then
        If Assistant.Visible Then
            Set objErrBalloon = Assistant.NewBalloon
            With objErrBalloon
                .Mode = msoModeModal
                .Heading = strWizName
                .Text = strErrMsg
                .Button = msoButtonSetOK
                .Icon = msoIconAlert
            End With
            objErrBalloon.Show
            If Assistant.BalloonError = msoBalloonErrorNone Then
                Err.Clear
                Exit Sub
            End If
        End If
    End If
    
DisplayMsgBox:
    MsgBox strErrMsg, vbExclamation + vbOKOnly + vbApplicationModal, strWizName
    Err.Clear
    
End Sub
'if there exists a PageSize key with a value of A4 then change
'activedocument's page size to be A4
Private Sub SetPageSize()
    Dim strProperty As String
    
    fChangeToA4 = False
    fChangeToLetter = False
    On Error GoTo TryLetterPageSize
    strProperty = ""
    strProperty = System.PrivateProfileString("", strREG_SETTINGS_BASE_KEY, strREG_PAGE_SIZE)
    If strProperty = strA4_SETTING Then
        If strWIZ_SAVED_AS <> "A4" Then
            ActiveDocument.PageSetup.PaperSize = wdPaperA4
            fChangeToA4 = True
        End If
    End If

TryLetterPageSize:
    On Error GoTo -1 'resets Err and the error handler
    On Error GoTo ExitSub
    If Len(strProperty) = 0 Then
    'registry entry was not found. Wizard should have letter size settings
        If strWIZ_SAVED_AS = "A4" Then
            ActiveDocument.PageSetup.PaperSize = wdPaperLetter
            fChangeToLetter = True
        End If
    End If
ExitSub:
    Err.Clear
End Sub

' End Common Module
Attribute VB_Name = "Fax"
Option Explicit

'Standard Claimer

''******************************************************************************
'TO BE LOCALIZED
''******************************************************************************
'Style names
Public Const strSTY_RETURN_ADDR     As String = "Absender"
Public Const strSTY_DOC_LABEL       As String = "Dokumentbeschriftung"
Public Const strSTY_COMPANY_NAME    As String = "Firmenname"
Public Const strSTY_MSG_HDR_FIRST   As String = "Nachrichtenkopf Anfang"
Public Const strSTY_MSG_HDR_LABEL   As String = "Nachrichtenkopfbeschriftung"
Public Const strSTY_MSG_HDR_LAST    As String = "Nachrichtenkopf Ende"

'misc strings
Public Const strPHONE   As String = "Telefon:"
Public Const strFAX     As String = "Fax:"
Public Const strPAGES   As String = "Seiten:"
Public Const strTO      As String = "An:"
Public Const strFROM    As String = "Von:"
Public Const strDATE    As String = "Datum:"
Public Const strRE      As String = "Betreff:"
Public Const strCC      As String = "Cc:"

Public Const strCOMPANY         As String = "Firma:"
Public Const strFAX_NUMBER      As String = "TELEFAX:"
Public Const strPHONE_NUMBER    As String = "TELEFON:"
Public Const strTOTAL_NO_PAGES  As String = "GESAMTSEITEN (EINSCHL. DIESER SEITE):"
Public Const strSENDER_REF_NUMBER As String = "UNSER ZEICHEN:"
Public Const strYOUR_REF_NUMBER As String = "IHR ZEICHEN:"

Public Const strEMPTY_MACRO As String = "EmptyMacro "
Public Const strNONE        As String = "<kein>" 'choice to list of merge field
                                                 'names found in data source
                                'doc. if there is no field for last name.
                                'if the user selected this choice we don't
                                'insert a merge field for last name in the cover sheet.
Public Const strFLD_NAME As String = "Name" 'to select the field containing recipient name
                                    'from the fields present in the data source
Public Const strFLD_FAX As String = "Fax" 'to select the merge field containing fax number

Public Const strCLICK_HERE_NAME     As String = "[Hier klicken und Name eingeben]"
Public Const strCLICK_HERE_PAGES    As String = "[Hier Gesamtseitenzahl eingeben]"
Public Const strCLICK_HERE_SUBJECT  As String = "[Hier klicken und Betreff eingeben]"
Public Const strCLICK_HERE_COMMENTS As String = "[Hier klicken und Bemerkungen eingeben]"
Public Const strCLICK_HERE_COMPANY  As String = "[Hier klicken und Firmenname eingeben]"
Public Const strCLICK_HERE_PHONE_NUMBER As String = "[Hier klicken und Telefonr. eingeben]"
Public Const strCLICK_HERE_FAX_NUMBER As String = "[Hier klicken und Faxnummer eingeben]"
Public Const strCLICK_HERE_REF_NUMBER As String = "[Hier klicken und 'Ihr Zeichen' eingeben]"

'Address format to get info. from the Address book. Please be careful about the commas and
'spaces since you might end up with a space at the beginning of a name if not put at the right place.
'Please change the names only if you know the correct one.
Public Const strADDR_BK_NAME_FORMAT As String = "{{<PR_GIVEN_NAME> }{<PR_SURNAME>}|<PR_DISPLAY_NAME>}"
Public Const strADDR_BK_ADDR_FORMAT As String = "{<PR_POSTAL_ADDRESS>|{<PR_STREET_ADDRESS>" & vbCr & "}{<PR_POSTAL_CODE> }{<PR_LOCALITY>}}"
Public Const strADDR_BK_FAXNUM_FORMAT As String = "{<PR_PRIMARY_FAX_NUMBER>|<PR_BUSINESS_FAX_NUMBER>|<PR_HOME_FAX_NUMBER>}"
Public Const strADDR_BK_PHONE_FORMAT As String = "{<PR_PRIMARY_TELEPHONE_NUMBER>|<PR_BUSINESS_TELEPHONE_NUMBER>|<PR_OFFICE_TELEPHONE_NUMBER>}"
Public Const strADDR_BK_COMPANY_FORMAT As String = "<PR_COMPANY_NAME>"

'status messages put up while faxing the cover sheet and document. For some messages
'I add "..." and so add "..." to all strings.
Public Const strFAXING_DOC_RECIPIENTS As String = "Faxe das Dokument an die Empf|fffd|nger..."
Public Const strFAXING_DOC_RECIPIENT As String = "Faxe das Dokument an den Empf|fffd|nger"
Public Const strFAXING_CS_RECIPIENTS As String = "Faxe das Deckblatt an die Empf|fffd|nger..."
Public Const strFAXING_CS_RECIPIENT As String = "Faxe das Deckblatte an den Empf|fffd|nger"
Public Const strFAXING_CS_TO As String = "Faxe das Deckblatt an"
Public Const strFAXING_DOC_TO As String = "Faxe das Dokumment an"

'the text in the last panel
'the first one is the default. The next string is used if the user selects no cover sheet, when
'we actually send the fax on clicking Finish
Public Const strLAST_PANEL_DFLT_TEXT As String = "Falls Probleme auftreten, starten Sie bitte den Fax-Assistenten erneut und geben die Faxnummer in einem anderen Format ein. Beachten Sie, da|fffd| h|fffd|ufig eine '0' vorgew|fffd|hlt werden mu|fffd|, damit das Faxger|fffd|t eine Amtsleitung erh|fffd|lt."
Public Const strLAST_PANEL_NOCOVSHT_TEXT As String = "Sie haben die ben|fffd|tigte Information eingegeben. Klicken Sie 'Fertigstellen' um das Fax zu versenden."

'strings necessary to display help in case of failure of Fax
Public Const strHLP_FAX_INSTALL As String = "Wenn Sie Windows 95, Windows NT 4.0 oder h|fffd|her einsetzen, k|fffd|nnen Sie jetzt ein Telefaxger|fffd|t installieren. Wenn Sie OK klicken, wird Ihnen Hilfe beim Einrichten gegeben."
'the next string is the title as it appears on Word's main window
Public Const strMS_WORD As String = "Microsoft Word"

'make sure that strCMD_BAR_TITLE is as long as strCMD_BTN_TEXT, so that strCMD_BTN_TITLE does not get clipped off
'when the command bar is displayed.
Public Const strCMD_BAR_TITLE   As String = "Fax-Assistent"
Public Const strCMD_BTN_TEXT    As String = "Fax jetzt senden"

Public Const strCURRENT_DOC     As String = "Das aktuelle Dokument ("
Public Const strRIGHT_PAREN     As String = ")"

'Window caption of the cover sheet (the document's name will follow if the user is faxing a document)
Public Const strWINDOW_CAPTION  As String = " - Fax-Deckblatt f|fffd|r "
'Window caption if user is not faxing a doc. and just created a cover sheet.
Public Const strCOVER_SHEET_CAPTION As String = " - Fax-Deckblatt"

'Text in merge fields inserted in the cover sheet
Public Const strFLD_FAX_NAME    As String = "Name"
Public Const strFLD_FAX_NUMBER  As String = "Faxnummer"

'In NT3.51, the printer name from the print set up dialog which is called when the user clicks on
'Other... , returns the printer name with the printer location after ON
'so if a printer name is \\abcd\efg with location "location1" then the printer
'name is returned a "\\abcd\efg ON location1. So we have to strip out the text
'after ON. That's what this constant is for. In other countries too is this text
'going to be ON?
Public Const strPRINTER_ON      As String = " ON "

Public Const iMAX_ADDR_LINES = 5 'max. # of lines address can have
'Error messages
Public Const strERR_MAX_ADDR_LINES  As String = "Die Adresse darf nicht mehr als 5 Zeilen haben."
Public Const strERR_NO_DATA_SRC     As String = "Der Assistent konnten die Datenquelle f|fffd|r den Serienbrief nicht finden."
Public Const strERR_CREATING_CMDBAR As String = "Der Assistent konnte die Fax-Assistent-Symbolleiste nicht erstellen."
Public Const strERR_NO_MAIN_DOC1     As String = "Das Dokument  ("
Public Const strERR_NO_MAIN_DOC2     As String = ") f|fffd|r das ein Deckblatt erstellt wird ist nicht ge|fffd|ffnet. Bitte |fffd|ffnen Sie das Dokument und starten Sie den Vorgang erneut."
Public Const strERR_DISPLAY_QUERY_OPTIONS As String = "Der Assistent konnte keine Serienbrief-Datens|fffd|tze finden."
Public Const strERR_CHOOSING_DOC As String = "Der Assistent konnte das ausgew|fffd|hlte Dokument nicht zum Fax-Versand verwenden."
Public Const strERR_RCPNTS_NOT_CHOSEN As String = "Der Assistent |fffd|berpr|fffd|ft ob die Adressen f|fffd|r die Empf|fffd|nger f|fffd|r dieses Telefax korrekt sind. Bitte klicken Sie OK und w|fffd|hlen Sie die Fax-Empf|fffd|nger aus."

'this tip is displayed in an Autodown balloon finally
Public Const strPOST_WIZARD_TIP_NO_MRG_FLD As String = "Geben Sie weitere Information in das Fax-Deckblatt ein und klicken Sie die " & strCMD_BTN_TEXT & "-Schaltfl|fffd|che auf der " & strCMD_BAR_TITLE & "-Symbolleiste. L|fffd|schen Sie die Felder in den |fffd| |fffd| Zeichen nicht. Der Fax-Assistent verwendet diese um das von Ihnen ausgew|fffd|hlte Dokument einzubinden."
'this tip is displayed if we inserted merge fields in the cover sheet i.e. in the case of multiple recipients
Public Const strPOST_WIZARD_TIP_MRG_FLD As String = "Geben Sie weitere Informationen in das Fax-Deckblatt ein und klicken Sie die " & strCMD_BTN_TEXT & "-Schaltfl|fffd|che auf der " & strCMD_BAR_TITLE & "-Symbolleiste. L|fffd|schen Sie die Felder in den |fffd| |fffd| Zeichen nicht. Der Fax-Assistent verwendet diese um das Dokument an die von Ihnen ausgew|fffd|hlten Empf|fffd|nger zu versenden."

'this message is put up after we successfully faxed everything
Public Const strMSG_FAX_SUCCESS As String = "Der Assistent hat Ihr Dokument versandt."

'the 72 factor in the below 2 measurements is conversion factor of inches to points
'contemporary styles have a left indent of 0.56"
Public Const sCONT_LEFT_INDENT As Single = 0.56 * 72
'While converting text to table, for the Contemporary style alone,
'I need to set the first column's width explicitly. For English text,
'0.5" is big enough. If the text in the first column is getting truncated
'in your language, then please increase this value.
Public Const sCONT_WIDTH_COL1 As Single = 0.6 * 72


'The date format need not be localized if VB does not require it.
'Medium date is of the format "02-Apr-94". If the standard date format
'is anything different in the country, then please change it.
'important to have MMMM and not mmmm, since mm refers to minutes in a time field
Public Const strDATE_FORMAT As String = "t. MMMM jjjj"

''******************************************************************************
'DO NOT LOCALIZE THE CONSTANTS/DECLARATIONS BEYOND THIS
''******************************************************************************
'the following are the names of the autotext entries in the wizard.
'DON'T CHANGE THE NAMES OF THE AUTOTEXT ENTRIES IN THE WIZARD.
'if you change them, then please change the following strings too, correspondingly
Public Const strAT_UNCHKD_BOX   As String = "Unchecked Box"
Public Const strAT_CHKD_BOX     As String = "Checked Box"
Public Const strCNTMPGFX2        As String = "cntmpgfx2"
Public Const strPOST_WIZ_BLN    As String = "Fax Post Wizard Balloon"

Public Const sA4_LEFT_MARGIN    As Single = 82.08
Public Const sA4_RIGHT_MARGIN    As Single = 81.36
Public Const sLETTER_MARGIN     As Single = 90
'key where setup writes company name
Public Const strREGKEY_CMPNY_NAME As String = "HKEY_CURRENT_USER\Software\Microsoft\MS Setup (ACME)\User Info"
Public Const strVALKEY_CMPNY_NAME As String = "DefCompany"

Public fDocChanged As Boolean 'set if user changes the doc. to be faxed

Public objMainDoc As Document 'main doc which has to be sent
Public objDataSrc As MailMergeDataSource ' main doc's data src

'SQL query used to select all names from the data source
Public Const strSELECT_QUERY As String = "Select * From "

'form and callback balloon constants
Public Const iMAX_PANEL As Integer = 6 'panel # of the last panel in
                             'the dialog (starts from 0)
Public rgstrAssistantMsg(iMAX_PANEL) As String   ' as many as there are states

Public strBULLET     As String
Public strSOFT_ENTER As String
Public rgstrNotes(3) As String
Public strQUOTE As String
'available styles
Public Const iSTY_PROFESSIONAL  As Integer = 0
Public Const iSTY_CONTEMPORARY  As Integer = 1
Public Const iSTY_ELEGANT       As Integer = 2

'array for holding long and short template names
Public rgstrTemplateFileNames(3, 3) As String
Public Const iLONG_NAME As Integer = 0
Public Const iSHORT_NAME As Integer = 1

Public iFaxStyle As Integer 'stores the fax style chosen
Public fStylesCopied As Boolean

Public fMSFAXEnabled As Boolean 'disabled in NT

'Panel numbers
Public Const iPANEL_RCPNTS As Integer = 3
Public Const iPANEL_SENDER As Integer = 5
Public Const iPANEL_STYLE  As Integer = 4

'Max. number of recipients
Public Const iMAX_RCPNTS As Integer = 5

Public fDocIsFormLtr As Boolean 'true if doc. is a form letter
'to store the data options query that the user selects for the form letter
Public strFormLetterSQL As String
Public strFormLetterSQL1 As String
Public strConnectString As String
Public fDocPresent   As Boolean 'true if there is an main doc. apart
                                'from the doc created by FileNew
'keeps track of which panel to be skipped.
'if we are enabling a panel, then we need to restore the shape's
'color to as it was before. rgiColorShape stores that color
Public rgfSkipPanel(iMAX_PANEL) As Boolean 'if rgfSkipPanel(i) is True,
                                            'then skip the ith panel
Public rgiColorShape(iMAX_PANEL) As Long
Public fCheckValidity As Boolean
Public fNoCovSht As Boolean 'False if user selects "No cover sheet"

Public iFaxOption       As Integer 'Fax program selected by the user
Public Const iMS_FAX    As Integer = 0  'Microsoft Fax
Public Const iDIFF_FAX  As Integer = 1  'Other than MS Fax
Public Const iNO_FAX    As Integer = 2  'just print without faxing the doc/cover sheet

Public fRegistryNamesRead As Boolean 'true if MRU list has been read from reg.

Dim rgstrFaxTitle(3)        As String
Dim rgstrChkBoxText(5)      As String 'text beside the check boxes
Public strAsstMsgRcpntsFormLtr As String 'assistant help for form letter recipients' panel
Public strAsstMsgRcpntsOrdDoc As String 'assistant help for ordinary doc. recipients' panel

'tip displayed in an autodown balloon after the wizard is done
Public fCreatedCmdBar           As Boolean 'tip is to be displayed only if cmd bar created

'arrays to get the MRU list of recipient names and numbers stored in the registry
Dim rgstrMRUFaxNames(iMAX_RCPNTS) As String
Dim rgstrMRUFaxNums(iMAX_RCPNTS)  As String

'arrays to get the recipients names and numbers that the user entered
Dim rgstrRcpntFaxNames(iMAX_RCPNTS) As String
Dim rgstrRcpntFaxNums(iMAX_RCPNTS)  As String
Public iNumRcpnts As Integer

'DO NOT LOCALIZE - CONTROL NAMES
Public Const strCBO_RCPNT_NAME  As String = "cboRcpntName"
Public Const strCBO_RCPNT_NUM   As String = "cboRcpntNum"
Public iCboRcpntNameFocus       As Integer

'DO NOT LOCALIZE - REGISTRY ENTRIES
Public Const strRCPNT_NAME      As String = "Name of recipient#"
Public Const strRCPNT_NUMBER    As String = "Number of recipient#"
Public Const strNUM_RCPNTS      As String = "Number of recipients"

'Help files
Public Const strWIN_HELP_FILE As String = "Windows.hlp"
Public Const strFAX_HELP_FILE As String = "awfax.hlp"

'contexts for the help
Public Const lCNTXT_FAX_INSTALL As Long = 461903903
Public Const lCNTXT_FAX_SEND As Long = 1698757633
Public Const HELP_COMMAND As Integer = 258 'hex value = 0x0102

'error number that word returns on fax not being installed
Public Const iERR_FAX_NOT_INSTALLED As Integer = 5663
Public Const iERR_FAX_NOT_SENT As Integer = 4559

'DO NOT LOCALIZE - REGISTRY ENTRIES REGARDING PRINTERS
Declare Function RegEnumKey Lib "advapi32.dll" Alias "RegEnumKeyA" _
(ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpName As String, ByVal cbName As Long) As Long

Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" _
(ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long

Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

Declare Function GetWindowsDirectory Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal strDir As String, ByVal uSize As Integer) _
As Integer

Declare Function FindWindow Lib "USER32" Alias "FindWindowA" (ByVal strWndClassName As String, _
ByVal strWndName As String) As Long

Declare Function WinHelp Lib "USER32" Alias "WinHelpA" (ByVal hwnd As Long, ByVal strFileName As String, _
ByVal wCmd As Integer, ByVal dwData As Any) As Integer


Public rgstrPrinterNames()  As String
Public iTotalNumPrinters    As Integer

Const HKEY_LOCAL_MACHINE As Long = &H80000002
'Const KEY_ALL_ACCESS As Long = &HF0063
Const ERROR_SUCCESS As Long = 0
Const ERROR_NO_MORE_ITEMS As Long = 259

'registry keys under which printer names are found
Const strREG_PROVIDERS As String = "System\CurrentControlSet\Control\Print\Providers\"
Const strREG_LOCAL_PRINTERS As String = "System\CurrentControlSet\Control\Print\Printers\"

'initialise the vars. whiehc refer to the wizard's name
Public Sub InitWizardName(fDummy As Boolean)
    
    strWizName = "Fax-Assistent"
    strWizLongName = "Fax-Assistent"
    strWizShortName = "Fax"

End Sub

'initialize strings specific to this wizard
Private Sub InitWizardStrings()
Dim i As Integer
    
    
    'fax title for the different styles
    rgstrFaxTitle(iSTY_CONTEMPORARY) = "Telefax-Deckblatt"
    rgstrFaxTitle(iSTY_ELEGANT) = "TELEFAX-DECKBLATT"
    rgstrFaxTitle(iSTY_PROFESSIONAL) = "Fax"
    
    'text appearing after the unchecked boxes
    rgstrChkBoxText(1) = "Dringend"
    rgstrChkBoxText(2) = "Zur Erledigung"
    rgstrChkBoxText(3) = "Zur Stellungnahme"
    rgstrChkBoxText(4) = "Zur Kenntnis"
    rgstrChkBoxText(5) = "Mit Dank zur|fffd|ck"
    
    'Assistant messages
    rgstrAssistantMsg(0) = "Sie k|fffd|nnen den Fax-Assistenten verwenden, um Telefaxe elektronisch zu versenden, Serienfaxe zu versenden, oder ein Telefax-Deckblatt zu erstellen, das dann mit einem Faxger|fffd|t versandt wird."
    rgstrAssistantMsg(1) = "Wenn Sie ein anderes Dokument versenden m|fffd|chten, |fffd|ffnen Sie das Dokument und starten Sie den Fax-Assistenten erneut."
    rgstrAssistantMsg(2) = "Microsoft Fax ist nicht verf|fffd|gbar, wenn Sie Windows NT verwenden. Sie k|fffd|nnen aber ein anderes Fax-Programme verwenden, das auf Ihrem Rechner installiert ist. Wann Ihr System den Fax-Versand nicht unterst|fffd|tzt, k|fffd|nnen Sie das Fax-Deckblatt ausdrucken und dann von einem Telefaxger|fffd|t versenden."
    rgstrAssistantMsg(iPANEL_RCPNTS) = "Wenn Sie den Fax-Assistenten bereits verwendet haben, erscheinen die Namen der letzten Fax-Empf|fffd|nger in der Drop-Down-Liste. Sie k|fffd|nnen auf einen Namen in der Liste klicken um ihn in das Telefax-Deckblatt zu |fffd|bernehmen."
    rgstrAssistantMsg(iPANEL_SENDER) = "Geben Sie die Absenderinformationen so ein, wie sie auf dem Fax-Deckblatt erscheinen sollen."
    rgstrAssistantMsg(iPANEL_STYLE) = "W|fffd|hlen Sie den Stil f|fffd|r das Fax-Deckblatt aus. Sie k|fffd|nnen das Aussehen dieser Seite vor dem Faxen mit den Formatierungsbefehlen von Word ver|fffd|ndern. Sie k|fffd|nnen auch Text oder Bemerkungen auf dem Deckblatt eingeben bevor Sie es faxen."
    rgstrAssistantMsg(iMAX_PANEL) = "Um eine Einstellung zu ver|fffd|dern, klicken Sie auf ""<Zur|fffd|ck""."
    'if user is faxing a form letter, we have a different set of controls in the Recipients panel. So, we change the help text too.
    strAsstMsgRcpntsFormLtr = "Klicken Sie auf das Datenfeld das die Namen der Fax-Empf|fffd|nger beinhaltet. Klicken Sie dann auf das Datenfeld, das die Faxnummern enth|fffd|lt und spezifizieren Sie ob es sich um Faxnummern oder Adre|fffd|bucheintr|fffd|ge handelt. Klicken Sie dann auf ""Alle"" um das Fax an alle Adressen in der Datenquelle zu senden, oder spezifizieren Sie die Empf|fffd|nger an Hand von Bedingungen."
    strAsstMsgRcpntsOrdDoc = "Wenn Sie den Fax-Assistenten bereits verwendet haben, erscheinen die Namen der letzten Fax-Empf|fffd|nger in der Drop-Down-Liste. Sie k|fffd|nnen auf einen Namen in der Liste klicken um ihn in das Telefax-Deckblatt zu |fffd|bernehmen."
    

    rgstrTemplateFileNames(iSTY_PROFESSIONAL, iLONG_NAME) = "Professionelles Fax.dot"
    rgstrTemplateFileNames(iSTY_PROFESSIONAL, iSHORT_NAME) = "Proffax.dot"
    rgstrTemplateFileNames(iSTY_CONTEMPORARY, iLONG_NAME) = "Aktuelles Fax.dot"
    rgstrTemplateFileNames(iSTY_CONTEMPORARY, iSHORT_NAME) = "Aktufax.dot"
    rgstrTemplateFileNames(iSTY_ELEGANT, iLONG_NAME) = "Elegantes Fax.dot"
    rgstrTemplateFileNames(iSTY_ELEGANT, iSHORT_NAME) = "Elegfax.dot"
    
    rgstrNotes(iSTY_PROFESSIONAL) = "Kommentar:"
    rgstrNotes(iSTY_CONTEMPORARY) = "Bemerkungen:"
    rgstrNotes(iSTY_ELEGANT) = "BEMERKUNGEN/KOMMENTARE:"
    
    ''**********************************************************************
    'DO NOT LOCALIZE BEYOND THIS POINT.
    ''******************************************************************************
    
    'initialize arrays with the color of the subway shapes for the panels
    For i = 0 To iMAX_PANEL
        rgfSkipPanel(i) = False
        rgiColorShape(i) = COLOR_LIGHTGREY
    Next i

    strBULLET = "|fffd|"
    strSOFT_ENTER = Chr$(11)
    strQUOTE = Chr$(34)
                                        
    'DO NOT LOCALIZE THE NEXT STRING. WE WANT TO STORE ONLY ONE SET
    'OF DIALOG VALUES IN THE REGISTRY.
    strRegSettingsKey = strREG_SETTINGS_BASE_KEY & "Fax Wizard"
End Sub

'initialises the form
Private Sub InitForm()
    On Error GoTo FatalError
    
    Set formWizard = New formWizDlg
    If formWizard Is Nothing Then
        DisplayErrorMsg strERR_INIT_FORM
        ReportError Err
    End If

    iCurrentPanel = 0
    formWizard.lblWizardName1.Caption = " " & strWizLongName & " "
    Exit Sub

FatalError:
    DisplayErrorMsg strERR_INIT_FORM
    ReportError Err
    
End Sub

Sub InitWizard(fDummy As Boolean)
    
    InitForm
    InitWizardStrings

    fNoCovSht = False
    fStylesCopied = False
End Sub

Public Sub SetMainDoc(fDummy As Boolean)
Dim cDocs As Integer
Dim i As Integer

    On Error GoTo FatalError
    
    fDocIsFormLtr = False
    fDocPresent = False
    fDocChanged = False
    cDocs = Application.Documents.Count
    
    If cDocs > 1 Then
    'we don't want to add the doc. that was just created thro' FileNew
        For i = 2 To cDocs
            formWizard.cboDocList.AddItem Documents(i).Name
        Next i

        formWizard.cboDocList.ListIndex = 0
        fDocPresent = True
    Else
        'just one doc. i.e the freshly created one
        Set objMainDoc = Nothing
    End If
    Exit Sub

FatalError:
    ReportError Err

End Sub

'checks the kind of document and sets fDocIsFormLtr
Public Sub CheckDocKind(objDoc As Document)
Dim objMM As MailMerge
Dim strQueryString As String
    On Error GoTo LReturn
    fDocIsFormLtr = False
    Set objMM = objMainDoc.MailMerge
    Set objDataSrc = objMM.DataSource
    If objDataSrc.Type = wdNoMergeInfo Then GoTo LReturn
    strQueryString = objDataSrc.QueryString
    strFormLetterSQL = Left$(strQueryString, 255)
    strFormLetterSQL1 = Mid$(strQueryString, 256)
    strConnectString = objDataSrc.ConnectString
    fDocIsFormLtr = True
    
    Exit Sub
LReturn:
    Err.Clear
    fDocIsFormLtr = False
End Sub

Public Sub CreateCoverSheet(fDummy As Boolean)
Dim strDocName As String
Dim objFps As PageSetup

    On Error GoTo FatalError
    Application.StatusBar = strCREATING_DOC
    Application.ScreenUpdating = False
    
    System.Cursor = wdCursorWait

    If fChangeToA4 Then
        Set objFps = ActiveDocument.PageSetup
        objFps.LeftMargin = sA4_LEFT_MARGIN
        objFps.RightMargin = sA4_RIGHT_MARGIN
    ElseIf fChangeToLetter Then
        Set objFps = ActiveDocument.PageSetup
        objFps.LeftMargin = sLETTER_MARGIN
        objFps.RightMargin = sLETTER_MARGIN
    End If
    
    If (((Not (fDocIsFormLtr)) And (iNumRcpnts > 1)) Or fDocIsFormLtr) Then _
        CreateDataSource
        
    StatusBar = strCREATING_DOC
    Select Case iFaxStyle
    Case iSTY_PROFESSIONAL
        CreateProfContCoverSheet
    Case iSTY_CONTEMPORARY
        CreateProfContCoverSheet
    Case iSTY_ELEGANT
        CreateElegCoverSheet
    End Select
    
    If (fDocPresent) And (Not (formWizard.optCovSht.Value)) Then
        strDocName = ActiveWindow.Caption & strWINDOW_CAPTION & objMainDoc.Name
    Else
        strDocName = ActiveWindow.Caption & strCOVER_SHEET_CAPTION
    End If
        
    With ActiveWindow
        .Caption = strDocName

        .View.TableGridlines = False
    End With
    ActiveDocument.UndoClear
    Selection.HomeKey wdStory
    
    With ActiveDocument.Content
        .SpellingChecked = True
        .GrammarChecked = True
    End With
    
    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'creates a data source for the cover sheet in the temp. directory
Private Sub CreateDataSource()
Dim objRng As Range
Dim strPath As String
Dim objDataSrcDoc As Document, objMM As MailMerge
Dim strDataSrcName As String
    On Error GoTo FatalError
    
    Set objMM = ActiveDocument.MailMerge
    objMM.MainDocumentType = wdFormLetters
    
    If (fDocIsFormLtr) Then
        objMM.OpenDataSource objDataSrc.Name, Connection:=strConnectString
        objMM.DataSource.QueryString = strFormLetterSQL & strFormLetterSQL1
        Exit Sub
    End If
    
    Set objDataSrcDoc = Application.Documents.Add
    
    Set objRng = objDataSrcDoc.Content
    
    CreateTableFromFaxInfo objRng
    
    strPath = Options.DefaultFilePath(wdTempFilePath)
    If Right$(strPath, 1) <> strPathSeparator Then _
        strPath = strPath & strPathSeparator
        
    strDataSrcName = strPath & "~$CovSht@" & Format$(Date, "dd-mm-yy") & "," & Format$(Time, "hh-mm-ss") & ".tmp"
    objDataSrcDoc.SaveAs strDataSrcName, wdFormatDocument
    objDataSrcDoc.Close wdDoNotSaveChanges
    
    'attach the data source doc. to activedocument (cover sheet)
    objMM.OpenDataSource strDataSrcName
    
    Exit Sub
FatalError:
    ReportError Err
End Sub


'creates a table in the data source document with names and numbers
'the format of the table is just like how one would create a data source doc.
'through Word
Private Sub CreateTableFromFaxInfo(objRange As Range)
Dim strText As String
Dim i As Integer

    On Error GoTo FatalError

    strText = strFLD_FAX_NAME & vbCr & strFLD_FAX_NUMBER
    
    'collect the names and numbers entered by the user
    For i = 1 To iNumRcpnts
        strText = strText & vbCr & rgstrRcpntFaxNames(i - 1) & vbCr & rgstrRcpntFaxNums(i - 1)
    Next i

    objRange.InsertBefore strText
    'Add a table with 2 columns and iNumRcpnts+1 rows
    objRange.Select
    Selection.ConvertToTable vbCr, iNumRcpnts + 1, 2
    
    Exit Sub
FatalError:
    ActiveDocument.Close wdDoNotSaveChanges 'close the data source doc.
    ReportError Err
End Sub

Public Function FCopyStyles(iStyle As Integer) As Boolean
    Dim strStyleName As String
    Dim strLongName As String
    Dim i As Integer
    
    On Error GoTo TemplateNotFound
LFindTemplate:
    ' Attempt to locate longname, then shortname template file
    i = iLONG_NAME
    strStyleName = strTemplatePath & rgstrTemplateFileNames(iStyle, iLONG_NAME)
    strLongName = strStyleName
    If Dir(strStyleName) <> "" Then GoTo LApplyStyles
LTryShortName:
    i = iSHORT_NAME
    strStyleName = strTemplatePath & rgstrTemplateFileNames(iStyle, iSHORT_NAME)

LApplyStyles:
    StatusBar = strAPPLYING
    
    ' Get styles
    ActiveDocument.CopyStylesFromTemplate (strStyleName)
    
    ' No Error
    fStylesCopied = True
    StatusBar = ""
    FCopyStyles = True
    Exit Function
    
TemplateNotFound:
    If i = iLONG_NAME Then
        i = iSHORT_NAME
        Err.Clear
        GoTo LTryShortName
    End If
    DisplayErrorMsg strERR_STYLE_NOT_FOUND & strLongName & strERR_STYLE_NOT_FOUND2
    fStylesCopied = False
    StatusBar = ""
    FCopyStyles = False
End Function

'creates professional/Contemporary style cover sheet
Private Sub CreateProfContCoverSheet()
Dim objRngBuffer1 As Range
Dim objRngBuffer2 As Range
Dim strCmpnyName As String, strName As String
Dim strMFFirstName As String, strMFLastName As String, strMFFaxNum As String
Dim objRngTextTable As Range
Dim objTable As Table

    On Error GoTo FatalError
    
    If iFaxStyle = iSTY_CONTEMPORARY Then
        InsertContAutoText
        objActiveRange.Collapse wdCollapseEnd
    End If
    
    InsertReturnAddress
    GetMergeFieldNames strMFFirstName, strMFLastName, strMFFaxNum
    
    'Insert company name
    strCmpnyName = formWizard.txtCompany.Text
    If (iFaxStyle = iSTY_PROFESSIONAL) Then
        If (Len(strCmpnyName)) Then
            objActiveRange.Style = strSTY_COMPANY_NAME
            objActiveRange.InsertBefore strCmpnyName & vbCr
            objActiveRange.Collapse wdCollapseEnd
        End If
        'Insert title
        objActiveRange.Style = strSTY_DOC_LABEL
        objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) & vbCr
        objActiveRange.Collapse wdCollapseEnd
    End If
    

    
    Set objRngTextTable = objActiveRange.Duplicate
    
'the topics To: and From: have a character style which has to be
'applied after the data has been written (since the data have a
'different style). so, use a range buffer
    
    '1st line text has style "Message Header First". The subsequent
    'lines have "Message Header"
    
    'Insert To:
    objActiveRange.Style = strSTY_MSG_HDR_FIRST
    objActiveRange.InsertBefore strTO
    Set objRngBuffer1 = objActiveRange.Duplicate

    'insert recipient name
    If (iNumRcpnts = 1) And (Not (fDocIsFormLtr)) Then
        objActiveRange.InsertAfter vbTab & rgstrRcpntFaxNames(0) & vbTab
    Else
        'insert appropriate field
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        If ((iNumRcpnts > 1) Or (fDocIsFormLtr)) Then
            InsertField objActiveRange, wdFieldMergeField, strMFFirstName, True
            If Len(strMFLastName) Then
                objActiveRange.InsertAfter strSPACE
                objActiveRange.Collapse wdCollapseEnd
                InsertField objActiveRange, wdFieldMergeField, strMFLastName, True
            End If
        Else
            InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        End If
        objActiveRange.InsertAfter vbTab
    End If
    
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert From:
    objActiveRange.InsertBefore strFROM
    Set objRngBuffer2 = objActiveRange.Duplicate
    
    'insert sender's name
    strName = formWizard.txtSenderName.Text
    If Len(strName) Then
        objActiveRange.InsertAfter vbTab & strName & vbCr
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        'insert macrobutton field.
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        objActiveRange.InsertParagraphAfter
    End If
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'next 3 lines in "Message Header" style
    'Insert Fax Number
    objActiveRange.Style = wdStyleMessageHeader
    
    objActiveRange.InsertBefore strFAX
    Set objRngBuffer1 = objActiveRange.Duplicate

    If (iNumRcpnts = 1) And (Not (fDocIsFormLtr)) Then
        objActiveRange.InsertAfter vbTab & rgstrRcpntFaxNums(0) & vbTab
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        'insert the appropriate field
        If ((iNumRcpnts > 1) Or (fDocIsFormLtr)) Then
            InsertField objActiveRange, wdFieldMergeField, strMFFaxNum, True
        Else
            InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_FAX_NUMBER, False
        End If
        objActiveRange.InsertAfter vbTab
    End If
    
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert Date
    objActiveRange.InsertBefore strDATE
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    'insert datefield
    InsertField objActiveRange, wdFieldTime, "\@ " & strQUOTE & strDATE_FORMAT & strQUOTE, True

    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    
    'Next line
    'Insert Phone
    objActiveRange.InsertBefore strPHONE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PHONE_NUMBER, False
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert Pages:
    objActiveRange.InsertBefore strPAGES
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PAGES, False
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'Insert Re:
    objActiveRange.InsertBefore strRE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_SUBJECT, False
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert CC:
    objActiveRange.InsertBefore strCC
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'convert the text into a table
    objRngTextTable.End = objActiveRange.End
    objRngTextTable.Select
    Set objTable = Selection.ConvertToTable(vbTab, 4, 4, AutoFit:=True, Format:=0)
    With objTable
        .Borders.Enable = False
        .Rows.SpaceBetweenColumns = 0
        If iFaxStyle = iSTY_CONTEMPORARY Then
            .Rows.LeftIndent = sCONT_LEFT_INDENT
            .Columns(1).Width = sCONT_WIDTH_COL1
        Else 'for professional style.
        'contemporary has autotext entry to insert the lines.
            .Rows.Borders(wdBorderHorizontal).Visible = True
            .Borders(wdBorderBottom).Visible = True
        End If
    End With
    'convert to table inserts a vbCr after the table.
    InsertCheckBoxes
    InsertBodyText
    
    If iFaxStyle = iSTY_CONTEMPORARY Then
        Set objActiveRange = ActiveDocument.Content
        objActiveRange.Collapse wdCollapseStart
        'Insert title
        objActiveRange.Style = strSTY_DOC_LABEL
        objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) ' & vbCr
    '    objActiveRange.Collapse wdCollapseEnd
    End If
    Exit Sub
FatalError:
    ReportError Err
End Sub
'creates an elegant style cover sheet
Private Sub CreateElegCoverSheet()
Dim objRngBuffer1 As Range
Dim objRngBuffer2 As Range
Dim strCmpnyName As String, strName As String
Dim strMFFirstName As String, strMFLastName As String, strMFFaxNum As String
Dim objRngTextTable As Range
Dim objTable As Table, objRow As Row
Dim i As Integer

    On Error GoTo FatalError
    
    InsertReturnAddress
    
    GetMergeFieldNames strMFFirstName, strMFLastName, strMFFaxNum
    
    'Insert company name
    strCmpnyName = formWizard.txtCompany.Text
    If (Len(strCmpnyName)) Then
        objActiveRange.Style = strSTY_COMPANY_NAME
        objActiveRange.InsertBefore strCmpnyName & vbCr
        objActiveRange.Collapse wdCollapseEnd
    End If
    
    'Insert title
    objActiveRange.Style = strSTY_DOC_LABEL
    objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) & vbCr
    objActiveRange.Collapse wdCollapseEnd
    
    Set objRngTextTable = objActiveRange.Duplicate
        
'the topics To: and From: have a character style which has to be
'applied after the data has been written (since the data have a
'different style). so, use a range buffer
    
    '1st line text has style "Message Header First". The subsequent
    'lines have "Message Header"
    
    'Insert To: & From:
    objActiveRange.Style = strSTY_MSG_HDR_FIRST
    
    objActiveRange.InsertBefore strTO & vbTab & strFROM
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert textual information in the next line
    If (iNumRcpnts > 1) Or fDocIsFormLtr Then
        InsertField objActiveRange, wdFieldMergeField, strMFFirstName, True 'Preserveformatting
        If Len(strMFLastName) Then
            objActiveRange.InsertAfter strSPACE
            objActiveRange.Collapse wdCollapseEnd
            InsertField objActiveRange, wdFieldMergeField, strMFLastName, True
        End If
    ElseIf iNumRcpnts = 1 Then
        objActiveRange.InsertBefore rgstrRcpntFaxNames(0)
    Else
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
    End If
    
    'insert name
    strName = formWizard.txtSenderName.Text
    If Len(strName) Then
        objActiveRange.InsertAfter vbTab & strName & vbCr
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        objActiveRange.InsertParagraphAfter
    End If

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL

    'next 3 lines in "Message Header" style
    'Insert FaxNumber and Date
    objActiveRange.Style = wdStyleMessageHeader
    
    objActiveRange.InsertBefore strFAX_NUMBER & vbTab & strDATE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert textual information in the next line
    
    'insert recipient number
    If (iNumRcpnts > 1) Or fDocIsFormLtr Then
        InsertField objActiveRange, wdFieldMergeField, strMFFaxNum, True 'Preserveformatting
    ElseIf iNumRcpnts = 1 Then
        objActiveRange.InsertBefore rgstrRcpntFaxNums(0)
    Else
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_FAX_NUMBER, False
    End If
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'insert datefield
    InsertField objActiveRange, wdFieldTime, "\@ " & strQUOTE & strDATE_FORMAT & strQUOTE, True
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Insert CompanyName & Pages
    objActiveRange.InsertBefore strCOMPANY & vbTab & strTOTAL_NO_PAGES
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert company name
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_COMPANY, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PAGES, False 'PreserveFormatting
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd

    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Phone Number & Sender's Reference Number
    objActiveRange.InsertBefore strPHONE_NUMBER & vbTab & strSENDER_REF_NUMBER
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PHONE_NUMBER, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_REF_NUMBER, False 'PreserveFormatting
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd

    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Phone Number & Sender's Reference Number
    objActiveRange.InsertBefore strRE & vbTab & strYOUR_REF_NUMBER
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_SUBJECT, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_REF_NUMBER, False 'PreserveFormatting

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'convert the text into a table
    objRngTextTable.End = objActiveRange.End '- 1 'don't want the last CR
    objRngTextTable.Select
    Set objTable = Selection.ConvertToTable(vbTab, 10, 2, Format:=0)
    objTable.Borders.Enable = False
    
    For i = 2 To 10 Step 2
        Set objRow = objTable.Rows(i)
        objRow.Range.ParagraphFormat.LeftIndent = 0.25 * 72
        'don't need the bottom border for the last row.
        If i <> 10 Then objRow.Borders(wdBorderBottom) = True
    Next i
    
    InsertCheckBoxes
    InsertBodyText
    
    Exit Sub
FatalError:
    ReportError Err
End Sub

'Get the names of the merge fields to be inserted in the cover sheet
'If the original doc. is a form letter then we need to insert the merge fields
'selected by the user. If not then insert the merge field names we created in the
'data source we created
Private Sub GetMergeFieldNames(strFirstName As String, strLastName As String, strFaxNum As String)
    On Error GoTo FatalError
    
    If (fDocIsFormLtr) Then
        'user selects names from drop-down of all possible mergefields in data source
        strFirstName = formWizard.cboFldsRcpntFirstName.Text
        strLastName = formWizard.cboFldsRcpntLastName.Text
        If (strLastName = strNONE) Then strLastName = ""
        strFaxNum = formWizard.cboFldsFaxNum.Text
    Else
       strFirstName = strFLD_FAX_NAME
       strLastName = ""
       strFaxNum = strFLD_FAX_NUMBER
    End If
    
    Exit Sub
FatalError:
    ReportError Err
End Sub
Private Sub InsertReturnAddress()
Dim strFromPh As String
Dim strFromFax As String
Dim strText As String, strAddress As String

    On Error GoTo FatalError
    
    'Set objActiveRange = ActiveDocument.Content
    'If iFaxStyle = iSTY_CONTEMPORARY Then objActiveRange.Collapse wdCollapseEnd

    strFromPh = formWizard.txtSenderPhone.Text
    strFromFax = formWizard.txtSenderFax.Text
    strAddress = formWizard.txtMailingAddr.Text

    Select Case iFaxStyle
    
    Case iSTY_CONTEMPORARY, iSTY_PROFESSIONAL
        strText = strAddress
        If Len(strText) Then strText = strText & vbCr
        If Len(strFromPh) <> 0 Then _
            strText = strText & strPHONE & strSPACE & strFromPh & vbCr

        If Len(strFromFax) <> 0 Then _
            strText = strText & strFAX & strSPACE & strFromFax & vbCr
        If Len(strText) = 0 Then strText = strText & vbCr
    Case iSTY_ELEGANT
        strText = StrReplaceCrLfWithText(strAddress, strSPACE & strBULLET & strSPACE)
        If Len(strText) Then strText = strText & vbCr
        'if you have phone number
        If Len(strFromPh) <> 0 Then
            strText = strText & strPHONE & strSPACE & strFromPh
            'check if you also have fax
            'instead of vbCr use space, bullet, space combination
            If Len(strFromFax) <> 0 Then _
                strText = strText & strSPACE & strBULLET & strSPACE & strFAX & strSPACE & strFromFax
            strText = strText & vbCr
        'check if you have only Fax
        ElseIf Len(strFromFax) <> 0 Then
            strText = strText & strFAX & strSPACE & strFromFax & vbCr
        End If
        
    End Select
    
    objActiveRange.Style = strSTY_RETURN_ADDR
    objActiveRange.InsertBefore strText
    objActiveRange.Collapse wdCollapseEnd
    Exit Sub
    
FatalError:
    ReportError Err
End Sub
'Inserts the check-boxes and the text associated with them
Private Sub InsertCheckBoxes()
Dim i As Integer
Dim R1 As Range
    On Error GoTo FatalError
    objActiveRange.Style = strSTY_MSG_HDR_LAST
    objActiveRange.Collapse wdCollapseEnd
    Set R1 = objActiveRange.Duplicate

    Set R1 = objWizTemplate.AutoTextEntries(strAT_UNCHKD_BOX).Insert(R1)

    objActiveRange.End = R1.End + 1
    objActiveRange.Start = R1.End + 1
    objActiveRange.InsertAfter strSPACE + rgstrChkBoxText(1) + vbTab
    objActiveRange.Style = wdStyleEmphasis

    objActiveRange.Collapse wdCollapseEnd
    For i = 2 To 5
        objActiveRange.FormattedText = R1.FormattedText
        objActiveRange.Collapse wdCollapseEnd
        objActiveRange.InsertAfter strSPACE + rgstrChkBoxText(i) + vbTab
        objActiveRange.Style = wdStyleEmphasis
        objActiveRange.Collapse wdCollapseEnd
    Next i

    'delete the previous character i.e the last tab
    objActiveRange.Start = objActiveRange.End - 1
    objActiveRange.Delete
    objActiveRange.InsertParagraph
    objActiveRange.Collapse wdCollapseEnd
    Exit Sub
    
FatalError:
    ReportError Err
End Sub

Private Sub InsertBodyText()
Dim R1 As Range
Dim strAfterText As String
    On Error GoTo FatalError
    
    If iFaxStyle = iSTY_ELEGANT Then
        strAfterText = vbCr
    Else
        strAfterText = strSPACE & strSPACE
    End If

    
    If iFaxStyle = iSTY_PROFESSIONAL Then _
        objActiveRange.InsertAfter strBULLET

    objActiveRange.InsertAfter rgstrNotes(iFaxStyle) & strAfterText
    
    Set R1 = objActiveRange.Duplicate
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_COMMENTS, False 'PreserveFormatting
    objActiveRange.Style = wdStyleBodyText
    R1.Style = strSTY_MSG_HDR_LABEL
    
    Exit Sub
FatalError:
    ReportError Err
End Sub
Private Sub InsertContAutoText()

    On Error GoTo FatalError
    Set objActiveRange = objWizTemplate.AutoTextEntries(strCNTMPGFX2).Insert(objActiveRange, True)
   
    Exit Sub
FatalError:
    DisplayErrorMsg strERR_AUTOTEXT_NOT_FOUND
End Sub


Public Sub RestoreDialogValues(fDummy As Boolean)
    Dim fAddrBkEnable As Boolean
    Dim i As Integer
    Dim strChkdAddr As String
    
    On Error GoTo FatalError
    StatusBar = strRST_SETTINGS
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
   
    fAddrBkEnable = Application.MAPIAvailable
    formWizard.cmdRcpntsAddrBk.Enabled = fAddrBkEnable
    formWizard.cmdSenderAddrBk.Enabled = fAddrBkEnable
    
'Setting options in Panel1 depending on whether a doc. is present or not
    If fDocPresent Then
        formWizard.optCurDoc.Value = True
        formWizard.optCurDocCovShtYes.Value = True
    Else
        'disable a bunch of options
        formWizard.optCurDoc.Enabled = False
        formWizard.cboDocList.Enabled = False
        formWizard.optCurDocCovShtNo.Enabled = False
        formWizard.optCurDocCovShtYes.Enabled = False
        formWizard.optCovSht.Value = True
        formWizard.frmRcpntsFormDoc.Visible = False
        formWizard.frmRcpntsOrdDoc.Visible = True
    
    End If

    'Panel2
    'read values from registry.
    iFaxOption = IRestorePref("Fax Option", 0)
    If InStr(UCase$(System.OperatingSystem), "NT") Then
        fMSFAXEnabled = False
        formWizard.optMSFax.Enabled = False
    Else
        fMSFAXEnabled = True
    End If
    'set printer in combo-box before disabling frmFaxDriver.
    GetAllPrinters
        
    'the controls are assumed to be enabled initially and are explicityly
    'only turned off, never turned on.
    If (iFaxOption = iMS_FAX) And Not (fMSFAXEnabled) Then
        If iTotalNumPrinters > 0 Then
            iFaxOption = iDIFF_FAX
        Else
            iFaxOption = iNO_FAX
        End If
    End If
    Select Case iFaxOption
        Case iMS_FAX:
            formWizard.optMSFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
        Case iDIFF_FAX:
            formWizard.optDifferentFax.Value = True
        Case iNO_FAX:
            formWizard.optNoFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
        Case Else
            iFaxOption = iNO_FAX
            formWizard.optNoFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
            
    End Select
    
    'Panel3
    fRegistryNamesRead = False
    
    'Panel5
    formWizard.txtSenderName.Text = Application.UserName

    i = ICountLines(Application.UserAddress, strChkdAddr, iMAX_ADDR_LINES)
    formWizard.txtMailingAddr.Text = strChkdAddr
    formWizard.txtSenderFax.Text = StrRestorePref("Sender Fax", "")
    formWizard.txtSenderPhone.Text = StrRestorePref("Sender Phone", "")
    
    'Panel 4
    iFaxStyle = IRestorePref("Coversheet Style", 0)
    If (iFaxStyle < iSTY_PROFESSIONAL) Or (iFaxStyle > iSTY_ELEGANT) Then _
        iFaxStyle = iSTY_PROFESSIONAL
    Select Case iFaxStyle
        Case iSTY_PROFESSIONAL
            formWizard.optStyleProf.Value = True
            formWizard.lblStyle0.Visible = True
        Case iSTY_CONTEMPORARY
            formWizard.optStyleCont.Value = True
            formWizard.lblStyle1.Visible = True
        Case iSTY_ELEGANT
            formWizard.optStyleEleg.Value = True
            formWizard.lblStyle2.Visible = True
    End Select
    
    On Error GoTo -1 'reset error trap
    On Error Resume Next
    formWizard.txtCompany.Text = System.PrivateProfileString("", strREGKEY_CMPNY_NAME, strVALKEY_CMPNY_NAME)
    fSettingsRestored = True
    System.Cursor = wdCursorNormal
    StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'sets default merge fields
Public Sub FillMergeFields(fDummy As Boolean)
Dim i As Integer, iCount As Integer
Dim iFirstName As Integer
Dim iLastName As Integer
Dim iFax As Integer
Dim rgstrNames() As String
Dim objFieldNames As MailMergeFieldNames
Dim objTempDoc As Document

    On Error GoTo FatalError
    iFirstName = -1
    iLastName = -1
    iFax = -1
    
    'reset the query options so that all names in the data src are selected
    
    Set objFieldNames = objDataSrc.FieldNames
    iCount = objFieldNames.Count
    ReDim rgstrNames(iCount - 1)
    For i = 1 To iCount
        rgstrNames(i - 1) = objFieldNames(i).Name
        If InStr(rgstrNames(i - 1), strFLD_NAME) Then
            If iFirstName = -1 Then
                iFirstName = i - 1
            ElseIf iLastName = -1 Then
                iLastName = i - 1
            End If
        ElseIf InStr(rgstrNames(i - 1), strFLD_FAX) Then
            If iFax = -1 Then iFax = i - 1
        End If
        
    Next i
    
    formWizard.cboFldsRcpntFirstName.List = rgstrNames
    formWizard.cboFldsRcpntLastName.List = rgstrNames
    formWizard.cboFldsFaxNum.List = rgstrNames
    
    formWizard.cboFldsRcpntFirstName.AddItem strNONE
    formWizard.cboFldsRcpntLastName.AddItem strNONE
    
    If (iFirstName <> -1) Then
        formWizard.cboFldsRcpntFirstName.Value = rgstrNames(iFirstName)
    Else
        formWizard.cboFldsRcpntFirstName.Value = strNONE
    End If
        
    If (iLastName <> -1) Then
        formWizard.cboFldsRcpntLastName.Value = rgstrNames(iLastName)
    Else
        formWizard.cboFldsRcpntLastName.Value = strNONE
    End If
        
    If (iFax <> -1) Then _
        formWizard.cboFldsFaxNum.Value = rgstrNames(iFax)

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'retrieves the Names and numbers stored in registry.
Sub ReadRegistryFaxNames(fDummy As Boolean)
Dim j As Integer, k As Integer
Dim objCtrls As Object
    On Error GoTo FatalError
    fRegistryNamesRead = True
    Set objCtrls = formWizard.mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    
    For j = 1 To iMAX_RCPNTS
        rgstrMRUFaxNames(j - 1) = StrRestorePref(strRCPNT_NAME & j, "")
        rgstrMRUFaxNums(j - 1) = StrRestorePref(strRCPNT_NUMBER & j, "")
    Next j
        
    
    For j = 0 To iMAX_RCPNTS - 1
        objCtrls(strCBO_RCPNT_NAME & j).List = rgstrMRUFaxNames
        objCtrls(strCBO_RCPNT_NUM & j).List = rgstrMRUFaxNums
    Next j
    
    Exit Sub
    
FatalError:
    ReportError Err
End Sub
Sub SaveDialogValues(fDummy As Boolean)
    On Error GoTo FatalError
    
    StatusBar = strSAVE_SETTINGS
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    System.PrivateProfileString("", strREG_SETTINGS_BASE_KEY, strREG_ASSISTANT_TIME_STAMP) = Format$(Now, "General Date")
    StoreValPref strREG_ASSISTANT_HELP, iLocalState
    
    StorePref "Fax Option", CStr(iFaxOption)
    If iFaxOption = iDIFF_FAX Then _
        StorePref "Fax Driver", formWizard.cboFaxDriver.Text
    
    StorePref "Sender Fax", formWizard.txtSenderFax.Text
    StorePref "Sender Phone", formWizard.txtSenderPhone.Text
    StorePref "Coversheet Style", CStr(iFaxStyle)
    
    If Not (fDocIsFormLtr) Then SaveRcpntsInRegistry
    
    fSettingsSaved = True
    System.Cursor = wdCursorNormal
    StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'stores the recipient names and numbers of iMAX_RCPNTS recipients.
'The name is tagged to the number. So, you can have a number without a name
'but not a name without a number
Private Sub SaveRcpntsInRegistry()
'Dim strName As String
Dim strNum As String
Dim i As Integer, j As Integer, k As Integer
Dim objCtrls As Object

    On Error GoTo FatalError
    k = 0
    'initialize the arrays so that even if the user has not
    'chosen any recipient we can still use the first entry of the arrays.
    rgstrRcpntFaxNames(0) = ""
    rgstrRcpntFaxNums(0) = ""
    iNumRcpnts = 0
    
    Set objCtrls = formWizard.mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    
    For i = 0 To iMAX_RCPNTS - 1
        strNum = StrSearchReplace(objCtrls(strCBO_RCPNT_NUM & i).Text, vbTab, " ") 'recipient number
        If (Len(strNum)) Then 'if number not empty
            rgstrRcpntFaxNums(k) = strNum 'store number
            rgstrRcpntFaxNames(k) = StrSearchReplace(objCtrls(strCBO_RCPNT_NAME & i).Text, vbTab, " ") 'and corresponding name
            k = k + 1
            StorePref strRCPNT_NUMBER & k, strNum 'store number
            StorePref strRCPNT_NAME & k, rgstrRcpntFaxNames(k - 1)
 
            j = objCtrls(strCBO_RCPNT_NUM & i).ListIndex
            
            'user selected one of the choices
            If j <> -1 Then rgstrMRUFaxNums(j) = ""  'already picked up this text
        End If
    Next i
    
    iNumRcpnts = k
    
    j = 0
    While (k < iMAX_RCPNTS) 'if we haven't yet iMAX_RCPNTS names
        'go through the array of orginally obtained recipients and
        'store which haven't yet been stored
        While ((j < iMAX_RCPNTS) And (Len(rgstrMRUFaxNums(j)) = 0))
            j = j + 1
        Wend
        
        If j = iMAX_RCPNTS Then
            GoTo LReturn 'no names left to fill
        Else
            k = k + 1
            StorePref strRCPNT_NAME & k, rgstrMRUFaxNames(j) 'store name
            StorePref strRCPNT_NUMBER & k, rgstrMRUFaxNums(j) 'and corresponding number
            rgstrMRUFaxNums(j) = ""
        End If
    Wend

LReturn:
    Exit Sub
FatalError:
    ReportError Err
End Sub

'Error will be taken care of in SetupDocForFax
'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub SaveRcpntsInDocVars(fSaveRcpnts As Boolean)
Dim i As Integer
Dim objVars As Variables
Dim strTemp As String, strFaxFld As String

    Set objVars = ActiveDocument.Variables
    objVars.Add strNUM_RCPNTS, iNumRcpnts
    
    If fSaveRcpnts Then
        If (iNumRcpnts > 0) Then
            For i = 1 To iNumRcpnts
                objVars.Add strRCPNT_NAME & i, rgstrRcpntFaxNames(i - 1)
                objVars.Add strRCPNT_NUMBER & i, rgstrRcpntFaxNums(i - 1)
            Next i
        End If
    End If
    
    If (fNoCovSht) Then
        objVars.Add "Cover Sheet Present", "0"
    Else
        objVars.Add "Cover Sheet Present", "1"
    End If
    
    strFaxFld = " "
    'store what fax option user chose.
    If (iFaxOption = iDIFF_FAX) Then
        objVars.Add "MS Fax Present", "0"
        objVars.Add "Fax Printer", formWizard.cboFaxDriver.Text
    Else
        objVars.Add "MS Fax Present", "1"
        If fDocIsFormLtr Then
            strFaxFld = formWizard.cboFldsFaxNum.Value
        Else
            strFaxFld = strFLD_FAX_NUMBER
        End If
    End If
    
    objVars.Add "Fax Field Name", strFaxFld

    'if doc. is present and is to be faxed then store relevant info. about doc.
    If (fDocPresent And (Not (formWizard.optCovSht.Value))) Then
        objVars.Add "Main Doc Present", "1"
        objVars.Add "Main Document Name", objMainDoc.Name
        
        'is the field a fax number or an Address Book Entry???
        If (fDocIsFormLtr) Then objVars.Add "Through Email", _
                formWizard.optFldFaxEntry.Value

    Else
        
        objVars.Add "Main Doc Present", "0"
    
    End If
    
End Sub


'removes vbCR & vbLF from the end of the string
'until the last character is not a vbLf or vbCr
Public Function StrRemoveCrLfFromEnd(strText As String) As String
    Dim strChar As String
    Dim i As Integer

    i = Len(strText)
    If (i = 0) Then GoTo LEnd

    strChar = Mid$(strText, i, 1)
    'check for the last character
    While (strChar = vbLf) Or (strChar = vbCr)
        i = i - 1
        strChar = Mid$(strText, i, 1)
    Wend
    
LEnd:
    StrRemoveCrLfFromEnd = Left$(strText, i)
End Function
'counts the number of lines in a string
Public Function ICountLines(ByVal strWhat As String, strNewText As String, iMax As Integer) As Integer
    Dim cLines As Integer, iPos As Integer
    
    strNewText = ""
    cLines = 0
    iPos = InStr(strWhat, vbCr)
    While iPos
        If iPos < Len(strWhat) Then
            If cLines < iMax Then strNewText = strNewText & Left$(strWhat, iPos - 1)
            cLines = cLines + 1
            strWhat = Mid$(strWhat, iPos + 1)
            iPos = InStr(strWhat, vbCr)
        Else
            If cLines < iMax Then strNewText = strNewText & Left$(strWhat, iPos - 1)
            If Len(strWhat) > 1 Then cLines = cLines + 1
            strWhat = ""
            iPos = 0
        End If
    Wend
    If strWhat <> "" Then
        If cLines < iMax Then strNewText = strNewText & strWhat
        cLines = cLines + 1
    End If
    
    ICountLines = cLines

End Function  ' CountLines

'inserts a field of type iFldType at the given range with strText as the text. Field replaces the text in objRng
'so pass a collapsed range always.and updates the range to be at the end
'of the inserted field.
Private Sub InsertField(objRng As Range, iFldType, strText As String, fPreserveFormatting)
    Dim objFld As Field
    
    On Error GoTo FatalError

    Set objFld = objRng.Fields.Add(objRng, iFldType, strText, fPreserveFormatting)
    
    Set objRng = objFld.Result
    With objRng
        .Collapse wdCollapseEnd
        .End = .End + 1
        .Start = .End
    End With
    
    Exit Sub
FatalError:
    ReportError Err
    
End Sub
'replaces all occurences of vbCR & vbLF with the delimiter string in strText
'returns the new string
Private Function StrReplaceCrLfWithText(strText As String, strDelim As String) As String
    Dim strRet As String, strTmp As String
    
    strRet = ""
    strTmp = strText
    If Len(strTmp) = 0 Then GoTo LEnd
    
    strRet = StrRemoveCrLfFromEnd(strTmp)
    'remove vbLf thro' search and replace
    strTmp = StrSearchReplace(strRet, vbLf, "")
    'now replace all occurrences of vbCr with strDelim
    strRet = StrSearchReplace(strTmp, vbCr, strDelim)
LEnd:
    StrReplaceCrLfWithText = strRet

End Function

'removes the character strSrch from strText.
'caller should make sure that strSrch is a one character string
'returns the string stripped off the character
Private Function StrSearchReplace(strText As String, strSrch As String, strReplace As String)
    Dim strRet As String, strTmp As String
    Dim iPos As Integer
    
    strRet = ""
    strTmp = strText

    iPos = InStr(strTmp, strSrch)
    
    While (iPos) 'presence of strChar
        strRet = strRet & Left$(strTmp, iPos - 1)
        If (iPos < Len(strTmp)) Then
            strRet = strRet & strReplace
            strTmp = Mid$(strTmp, iPos + 1)
            iPos = InStr(strTmp, strSrch)
        Else 'strSrch is the last character
            strTmp = ""
            iPos = 0
        End If
    Wend
        
    'append whatever is left of the original string
    strRet = strRet & strTmp

    StrSearchReplace = strRet
End Function

'Errors in SaveRcpntsInDocVars & CreateCmdBar gets propagated back
'this function
Public Sub SetupDocForFax(fDummy As Boolean)
    On Error GoTo FatalError

    If iFaxOption = iNO_FAX Then Exit Sub

    If (Not (fDocIsFormLtr)) And (iNumRcpnts = 0) And (iFaxOption = iMS_FAX) _
            Then Exit Sub
        
    'dont save recipient info for form letter
    SaveRcpntsInDocVars (Not (fDocIsFormLtr))
    
    If (fNoCovSht) Then 'fax the doc.
        If (Not (fDocIsFormLtr)) Then
            FaxRegDoc
        Else
            FaxFormLtr
        End If
    Else
        CreateCmdBar
    End If

    Exit Sub
FatalError:
    DisplayErrorMsg strERR_CREATING_CMDBAR
    ReportError Err
End Sub
'Error will be taken care of in SetupDocForFax
Private Sub CreateCmdBar()
Dim objCmdBar As CommandBar
Dim objBtn As CommandBarButton

    Application.CustomizationContext = ActiveDocument
    Set objCmdBar = Application.CommandBars.Add(strCMD_BAR_TITLE, Position:=msoBarFloating, Temporary:=True)

    'Add a button
    Set objBtn = objCmdBar.Controls.Add(msoControlButton, Temporary:=True)
    objBtn.Style = msoButtonCaption
    objBtn.Caption = strCMD_BTN_TEXT
    
    If (Not (fDocIsFormLtr)) Then
        objBtn.OnAction = "Fax.FaxRegDoc"
    Else
        objBtn.OnAction = "Fax.FaxFormLtr"
    End If
    
    objCmdBar.Visible = True
    
    fCreatedCmdBar = True
    Exit Sub

End Sub

'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub FaxRegDoc()

Dim fMSFax As Boolean
Dim fCovSht As Boolean
Dim iNumRcpnts As Integer
'Dim rgstrFaxNames(iMAX_RCPNTS) As String
Dim rgstrFaxNums(iMAX_RCPNTS) As String
Dim i As Integer
Dim strDocName As String
Dim objVars As Variables
Dim fMainDocPresent As Integer
Dim strErrorMsg As String
Dim strFaxPrinter As String, strActivePrinter As String
Dim objTmpMM As MailMerge, strFaxFld As String
Dim fSendMailAttach As Boolean


    On Error GoTo FatalError
    strErrorMsg = strERR_SEND_FAX
    fSendMailAttach = Application.Options.SendMailAttach
    
    Set objVars = ActiveDocument.Variables
    
    iNumRcpnts = Val(objVars(strNUM_RCPNTS).Value)
    
    fCovSht = Val(objVars("Cover Sheet Present").Value)
    fMSFax = Val(objVars("MS Fax Present").Value)
    fMainDocPresent = Val(objVars("Main Doc Present").Value)
    strFaxFld = objVars("Fax Field Name").Value
    
    If fMainDocPresent Then
        'obtain handle to main document
        strDocName = objVars("Main Document Name").Value
        If FInvalidMainDoc(objMainDoc, strDocName) Then Exit Sub
        'Set objMainDoc = Application.Documents(strDocName)
    End If
          
    For i = 1 To iNumRcpnts
'        rgstrFaxNames(i - 1) = objVars(strRCPNT_NAME & i).Value
        rgstrFaxNums(i - 1) = objVars(strRCPNT_NUMBER & i).Value
    Next i
    
    'if nonMSFax, then set the Fax driver to be the current printer
    If (Not (fMSFax)) Then
        strActivePrinter = Application.ActivePrinter
        strFaxPrinter = objVars("Fax Printer").Value
        If Len(strFaxPrinter) = 0 Then strFaxPrinter = " "
        Application.ActivePrinter = strFaxPrinter
     End If
    
    'fax the cover sheet first
    If (fCovSht) Then
        If (iNumRcpnts > 1) Then
            Set objTmpMM = ActiveDocument.MailMerge
            If fMSFax Then
                objTmpMM.Destination = wdSendToFax
                'MsgBox "MailMerging the cover sheet"
            Else 'non MS fax
                objTmpMM.Destination = wdSendToPrinter
            End If
            objTmpMM.MailAsAttachment = True
            objTmpMM.MailAddressFieldName = strFaxFld
            StatusBar = strFAXING_CS_RECIPIENTS
            objTmpMM.Execute
            
        ElseIf (iNumRcpnts = 1) And fMSFax Then
            StatusBar = strFAXING_CS_TO & " " & rgstrFaxNums(0) & "..."
            Application.Options.SendMailAttach = True
            ActiveDocument.SendFax rgstrFaxNums(0)
                'MsgBox "Faxing to  " & rgstrFaxNames(0) & rgstrFaxNums(0)
        Else 'non MS fax
            StatusBar = strFAXING_CS_RECIPIENT & "..."
            ActiveDocument.PrintOut
        End If
    End If
    
    If fMainDocPresent = 0 Then GoTo LResetPrinter 'if no main doc. then deesh
    
    If (iNumRcpnts = 0) And Not (fMSFax) Then objMainDoc.PrintOut
    
    'send the main doc.
    If fMSFax Then Application.Options.SendMailAttach = True
    For i = 0 To iNumRcpnts - 1
        If fMSFax Then
            StatusBar = strFAXING_DOC_TO & " " & rgstrFaxNums(i)
            objMainDoc.SendFax rgstrFaxNums(i)
            'MsgBox "Faxing to  " & rgstrFaxNames(i) & rgstrFaxNums(i)
        Else
            StatusBar = strFAXING_DOC_RECIPIENT & " " & CStr(i + 1) & "..."
            objMainDoc.PrintOut
        End If
        
    Next i
    
LResetPrinter:
'reset printer for non MS fax
    If fMSFax Then
        Application.Options.SendMailAttach = fSendMailAttach
    Else
        Application.ActivePrinter = strActivePrinter
    End If
    DisplayPostWizTip strMSG_FAX_SUCCESS, True
    'DeleteCmdBar strCMD_BAR_TITLE
    Exit Sub
    
FatalError:
    i = Err.Number
    If i Then strErrorMsg = strErrorMsg & vbCr & Err.Description
    'if Fax not installed error message
    If i = iERR_FAX_NOT_INSTALLED Then _
        strErrorMsg = strErrorMsg & vbCr & strHLP_FAX_INSTALL
    DisplayTip strErrorMsg
'reset printer for non MS fax
    If fMSFax Then
        Application.Options.SendMailAttach = fSendMailAttach
    Else
        Application.ActivePrinter = strActivePrinter
    End If
    
    If i = iERR_FAX_NOT_INSTALLED Then
        DisplayHelp strWIN_HELP_FILE, lCNTXT_FAX_INSTALL
    ElseIf i = iERR_FAX_NOT_SENT And fMSFax Then
        DisplayHelp strFAX_HELP_FILE, lCNTXT_FAX_SEND
    End If
End Sub
'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub FaxFormLtr()

Dim fMSFax As Boolean
Dim fCovSht As Boolean
Dim i As Integer
Dim strDocName As String
Dim iDestination As Long
Dim objVars As Variables
Dim fMainDocPresent As Integer
Dim strErrorMsg As String
Dim strFaxPrinter As String, strActivePrinter As String
Dim objTmpMM As MailMerge, strFaxFld As String

    On Error GoTo FatalError

    strErrorMsg = strERR_SEND_FAX
    Set objVars = ActiveDocument.Variables

    fCovSht = Val(objVars("Cover Sheet Present").Value)
    fMSFax = Val(objVars("MS Fax Present").Value)
    fMainDocPresent = Val(objVars("Main Doc Present").Value)
    strFaxFld = objVars("Fax Field Name").Value
    
    If fMainDocPresent Then
        'obtain handle to main document
        strDocName = objVars("Main Document Name").Value
        If FInvalidMainDoc(objMainDoc, strDocName) Then Exit Sub
        'Set objMainDoc = Application.Documents(strDocName)
    End If
    
    If fMSFax Then
        If Val(objVars("Through Email").Value) Then
            iDestination = wdSendToEmail
        Else
            iDestination = wdSendToFax
        End If
    Else
        iDestination = wdSendToPrinter
        'if nonMSFax, then set the Fax driver to be the current printer
        strActivePrinter = Application.ActivePrinter
        strFaxPrinter = objVars("Fax Printer").Value
        If Len(strFaxPrinter) = 0 Then strFaxPrinter = " "
        Application.ActivePrinter = strFaxPrinter
    End If
    
    'send the coversheet first
    If (fCovSht) Then
        Set objTmpMM = ActiveDocument.MailMerge
        objTmpMM.Destination = iDestination 'MsgBox "MailMerging activdoc (coversheet) "
        objTmpMM.MailAddressFieldName = strFaxFld
        objTmpMM.MailAsAttachment = True
        StatusBar = strFAXING_CS_RECIPIENTS
        objTmpMM.Execute
    End If
 
    If fMainDocPresent = 0 Then GoTo LResetPrinter
    
    'fax the main document
    Set objTmpMM = objMainDoc.MailMerge
    objTmpMM.Destination = iDestination
    objTmpMM.MailAddressFieldName = strFaxFld
    objTmpMM.MailAsAttachment = True
    StatusBar = strFAXING_DOC_RECIPIENTS
    objTmpMM.Execute
    'MsgBox "MailMerging main doc."

LResetPrinter:
'reset printer for non MS fax
    ActiveDocument.Fields.Update
    If (Not (fMSFax)) Then Application.ActivePrinter = strActivePrinter
    DisplayPostWizTip strMSG_FAX_SUCCESS, True
    'DeleteCmdBar strCMD_BAR_TITLE
    Exit Sub
    
FatalError:
    i = Err.Number
    If i Then strErrorMsg = strErrorMsg & vbCr & Err.Description
    'if Fax not installed error message
    If i = iERR_FAX_NOT_INSTALLED Then _
        strErrorMsg = strErrorMsg & vbCr & strHLP_FAX_INSTALL
        
    DisplayTip strErrorMsg
    
'reset printer for non MS fax
    If (Not (fMSFax)) Then Application.ActivePrinter = strActivePrinter
    
    If i = iERR_FAX_NOT_INSTALLED Then
        DisplayHelp strWIN_HELP_FILE, lCNTXT_FAX_INSTALL
    ElseIf i = iERR_FAX_NOT_SENT And fMSFax Then
        DisplayHelp strFAX_HELP_FILE, lCNTXT_FAX_SEND
    End If
End Sub

'To display help using help files. Assuming that the help files are present in
'the windows directory
Private Sub DisplayHelp(strFile As String, ByVal lContext As Long)
    Dim iSize As Integer
    Dim strTmpBuffer As String
    Dim j As Integer, i As Integer
    Dim strWinDir As String, strWndName As String
    Dim hOpusWin As Long, lResult As Long
    Dim strMacroName As String
    
    'Get windows directory
    i = 512
    strTmpBuffer = String$(i, 0)
    j = 0
    strWinDir = ""
    j = GetWindowsDirectory(strTmpBuffer, i)
    
    If j Then
        If (j > i) Then j = i
        
        strWinDir = Left$(strTmpBuffer, j)
        If Right$(strWinDir, 1) <> strPathSeparator Then _
            strWinDir = strWinDir & strPathSeparator
    End If
    
    'Find word's window
    strWndName = strMS_WORD
    If ActiveWindow.WindowState = wdWindowStateMaximize Then _
        strWndName = strWndName & " - " & ActiveWindow.Caption
    hOpusWin = FindWindow("OpusApp", strWndName)
    If hOpusWin = 0 Then GoTo LNotFindWindow
    
    'display help
    strMacroName = "JH(" & strQUOTE & strQUOTE & " , " & lContext & ")"
    lResult = WinHelp(hOpusWin, strWinDir & strFile, HELP_COMMAND, strMacroName)
    
LNotFindWindow:
End Sub
'displays a tip during post-wizard options
'assumes that Assistant is present since it is called from post-wizard balloon
Private Sub DisplayTip(strTip As String)
    Dim objBlnTip As Balloon
    On Error GoTo FatalError
    
    Set objBlnTip = Assistant.NewBalloon
    
    With objBlnTip
        .Mode = msoModeModal
        .Heading = strWizName
        .Text = strTip
        .Button = msoButtonSetOK
    End With
    objBlnTip.Show
    
    If Assistant.BalloonError <> msoBalloonErrorNone Then GoTo FatalError

    Exit Sub

FatalError:
    Err.Clear
    'MsgBox strTip, vbOKOnly + vbApplicationModal, strWizName
End Sub
'ROUTINES TO OBTAIN PRINTERS FROM REGISTRY
'fills rgstrPrinterNames with the local and remote printer names obtained
'from the registry. iTotalNumPrinters has the number of printer
'names obtained.
Sub GetAllPrinters()
Dim i As Integer

    iTotalNumPrinters = 0
    
    GetLocalPrinters
    GetRemotePrinters
    
    If (iTotalNumPrinters > 0) Then
        ReDim Preserve rgstrPrinterNames(iTotalNumPrinters - 1)
        formWizard.cboFaxDriver.List = rgstrPrinterNames
        formWizard.cboFaxDriver.ListIndex = 0
    End If
    'if no printers, then the user can use cmdOtherPrinters to select one
    'if we failed to enumerate some printer
    
End Sub
Sub GetRemotePrinters()
    Dim hr As Long
    Dim hSubKey As Long

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_PROVIDERS, hSubKey)
    If hr <> ERROR_SUCCESS Then Exit Sub
    
    GetRemotePrinterNames (hSubKey)

    RegCloseKey (hSubKey)
    
End Sub

Sub GetProviderPrinters(strProvider As String)
Dim hr As Long
Dim hKeyProviderServers As Long
Dim lpPrinterServer As String, strPrinterServer As String
Dim cbPrinterServer As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterServer As Integer

    cbPrinterServer = 256
    lpPrinterServer = String$(cbPrinterServer, 0)
    dwPrinterIndex = 0


    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_PROVIDERS & strProvider & "\Servers", hKeyProviderServers)

    If hr <> ERROR_SUCCESS Then GoTo LEndGetProviderPrinters
            
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterServer = String$(cbPrinterServer, 0)
        
        hr = RegEnumKey(hKeyProviderServers, dwPrinterIndex, lpPrinterServer, cbPrinterServer)
        
        If hr <> ERROR_SUCCESS Then GoTo LCloseProviderServersKey
        
        iLenPrinterServer = InStr(lpPrinterServer, Chr$(0))
        If (iLenPrinterServer > 1) Then 'no name
            strPrinterServer = Left$(lpPrinterServer, iLenPrinterServer - 1)
            GetPrinterNamesFromServer strProvider, strPrinterServer
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
LCloseProviderServersKey:
    RegCloseKey (hKeyProviderServers)
    
LEndGetProviderPrinters:
End Sub

Sub GetPrinterNamesFromServer(strProvider As String, strPrinterServer As String)
Dim hr As Long
Dim hKeyPrinterServers As Long
Dim lpPrinterName As String, strPrinterName As String
Dim strPrinter As String
Dim cbPrinterName As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterName As Integer
Dim strRegPrinterServers As String


    cbPrinterName = 256
    lpPrinterName = String$(cbPrinterName, 0)
    dwPrinterIndex = 0

    On Error Resume Next
    strRegPrinterServers = strREG_PROVIDERS & strProvider & "\Servers\" & strPrinterServer & "\Printers"
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strRegPrinterServers, hKeyPrinterServers)

    If hr <> ERROR_SUCCESS Then GoTo LEndGetProviderPrinters
            
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterName = String$(cbPrinterName, 0)
        
        lRet = RegEnumKey(hKeyPrinterServers, dwPrinterIndex, lpPrinterName, cbPrinterName)
        
        If lRet <> ERROR_SUCCESS Then GoTo LClosePrinterServersKey
        
        iLenPrinterName = InStr(lpPrinterName, Chr$(0))
        If (iLenPrinterName > 1) Then 'no name
            strPrinter = Left$(lpPrinterName, iLenPrinterName - 1)
            strPrinterName = ""
            strPrinterName = System.PrivateProfileString("", "HKEY_LOCAL_MACHINE\" & strRegPrinterServers & "\" & strPrinter, "Name")
            
            If Len(strPrinterName) <> 0 Then
                If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
                rgstrPrinterNames(iTotalNumPrinters) = UCase$("\\" & strPrinterServer & "\" & strPrinterName)
                iTotalNumPrinters = iTotalNumPrinters + 1
            End If
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
LClosePrinterServersKey:
    RegCloseKey (hKeyPrinterServers)
    
LEndGetProviderPrinters:

End Sub

Sub GetRemotePrinterNames(hKey As Long)
    Dim dwProviderIndex As Long
    Dim cbProviderName As Long
    Dim lpProviderName As String
    Dim lRet As Long, iLenProviderName  As Integer

    Dim strProviderName As String
  
    cbProviderName = 256
    dwProviderIndex = 0

    lRet = ERROR_SUCCESS
    
    'get the list of providers and call GetProviderPrinters for each provider
    While (lRet = ERROR_SUCCESS)
        lpProviderName = String$(cbProviderName, 0)
        
        lRet = RegEnumKey(hKey, dwProviderIndex, lpProviderName, cbProviderName)
        
        If (lRet <> ERROR_SUCCESS) Then GoTo LEnd
        
        iLenProviderName = InStr(lpProviderName, Chr$(0)) 'length of provider name
        
        If (iLenProviderName > 1) Then
            strProviderName = Left$(lpProviderName, iLenProviderName - 1)
            GetProviderPrinters (strProviderName)
        End If

        dwProviderIndex = dwProviderIndex + 1
    Wend
    
LEnd:

End Sub

Sub GetLocalPrinters()
    Dim hr As Long
    Dim hSubKey As Long

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_LOCAL_PRINTERS, hSubKey)
    If hr <> ERROR_SUCCESS Then Exit Sub

    GetLocalPrinterNames (hSubKey)

    RegCloseKey (hSubKey)
    
End Sub

Sub GetLocalPrinterNames(hKey As Long)

Dim lpPrinterName As String, strPrinterName As String
Dim strPrinter As String
Dim cbPrinterName As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterName As Integer

    cbPrinterName = 256
    dwPrinterIndex = 0

    On Error Resume Next
    
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterName = String$(cbPrinterName, 0)
        
        lRet = RegEnumKey(hKey, dwPrinterIndex, lpPrinterName, cbPrinterName)
        
        If lRet <> ERROR_SUCCESS Then GoTo LEndLocalPrinters
        
        iLenPrinterName = InStr(lpPrinterName, Chr$(0))
        If (iLenPrinterName > 1) Then 'no name
            strPrinter = Left$(lpPrinterName, iLenPrinterName - 1)
            strPrinterName = ""
            strPrinterName = System.PrivateProfileString("", "HKEY_LOCAL_MACHINE\" & strREG_LOCAL_PRINTERS & strPrinter, "Name")
            
            If Len(strPrinterName) <> 0 Then 'if valid name, add to list
                If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
                
                rgstrPrinterNames(iTotalNumPrinters) = UCase$(strPrinterName)
                
                iTotalNumPrinters = iTotalNumPrinters + 1
            End If
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
    
LEndLocalPrinters:
End Sub

'displays post wizard tip in an autodown balloon if Assistant is visible
Public Sub DisplayPostWizTip(strTip As String, fMsgBox As Boolean)

    Dim objTipBalloon As Balloon

    On Error GoTo TipError
    If fMsgBox Then
        If Assistant.Visible = False Then GoTo TipError
    End If
    Set objTipBalloon = Assistant.NewBalloon
    With objTipBalloon
        .Mode = msoModeAutoDown
        .Heading = strWizName
        .Button = msoButtonSetNone
        .Text = strTip
    End With
    objTipBalloon.Show

    If Assistant.BalloonError <> msoBalloonErrorNone Then GoTo TipError
    
TipError:
    Err.Clear
    If fMsgBox Then MsgBox strTip, vbInformation + vbOKOnly + vbApplicationModal, strWizName
End Sub

Private Function FInvalidMainDoc(objMainDoc As Document, strDocName As String) As Boolean
    On Error GoTo NoDoc
    Set objMainDoc = Application.Documents(strDocName)
    FInvalidMainDoc = False
    Exit Function
NoDoc:
    DisplayErrorMsg strERR_NO_MAIN_DOC1 & strDocName & strERR_NO_MAIN_DOC2
    FInvalidMainDoc = True
End Function

Public Sub DeleteCmdBar(strCmdBarName)
    On Error Resume Next
    Application.CommandBars(strCmdBarName).Delete
    Err.Clear
End Sub

Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Document_New()
    Common.StartWizard
End Sub
Attribute VB_Name = "UncheckIt"

Public Sub Main()
WordBasic.WW7_EditAutoText Name:="Unchecked Box", Context:=1, InsertAs:=0, Insert:=1
End Sub
Attribute VB_Name = "formWizDlg"
Attribute VB_Base = "0{32A04F47-52E7-11D0-B5E8-00AA00BBB76C}{32A04F41-52E7-11D0-B5E8-00AA00BBB76C}"
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Sub cboDocList_Click()
    On Error GoTo CantChangeDoc
    
    fDocChanged = True

    Set objMainDoc = Documents(cboDocList.Text)

    CheckDocKind objMainDoc
    
    If (fDocIsFormLtr) Then
        frmRcpntsFormDoc.Visible = True
        frmRcpntsOrdDoc.Visible = False
        FillMergeFields (True)
        'change the help text for the recipients panel
        rgstrAssistantMsg(iPANEL_RCPNTS) = strAsstMsgRcpntsFormLtr
    Else
        'if combo-boxes have not been initialized during setup
        If (Not (fRegistryNamesRead)) Then ReadRegistryFaxNames (True)
        frmRcpntsFormDoc.Visible = False
        frmRcpntsOrdDoc.Visible = True
        'change the help text for the recipients panel
        rgstrAssistantMsg(iPANEL_RCPNTS) = strAsstMsgRcpntsOrdDoc
    End If
    Exit Sub
    
CantChangeDoc:
    DisplayErrorMsg strERR_CHOOSING_DOC
    ReportError Err
End Sub

Private Sub cboRcpntName0_Enter()
    iCboRcpntNameFocus = 0
End Sub
Private Sub cboRcpntName1_Enter()
    iCboRcpntNameFocus = 1
End Sub
Private Sub cboRcpntName2_Enter()
    iCboRcpntNameFocus = 2
End Sub
Private Sub cboRcpntName3_Enter()
    iCboRcpntNameFocus = 3
End Sub
Private Sub cboRcpntName4_Enter()
    iCboRcpntNameFocus = 4
End Sub

Private Sub cmdBack_Click()
Dim i As Integer
    Select Case iCurrentPanel
        Case 1
          
        Case 3

    End Select

    i = iCurrentPanel - 1
    While (i > 0 And rgfSkipPanel(i))
        i = i - 1
    Wend
    
    JumpToPanel (i)
End Sub

Private Sub cmdCancel_Click()
    Err.Clear
    ReportError Err
End Sub

Private Sub cmdFinish_Click()
Dim strTmp As String, strNewText As String
Dim fRestoredNow As Boolean
    fRestoredNow = Not (fSettingsRestored)
    If Not (fSettingsRestored) Then
        SetMainDoc (True)
        RestoreDialogValues (True)
    End If
    
    If iCurrentPanel = iPANEL_SENDER Then
        If fCheckValidity Then
            strTmp = StrRemoveCrLfFromEnd(txtMailingAddr.Text)
            If ICountLines(strTmp, strNewText, iMAX_ADDR_LINES) > iMAX_ADDR_LINES Then
                DisplayErrorMsg (strERR_MAX_ADDR_LINES)
                txtMailingAddr.SelStart = 0
                txtMailingAddr.SelLength = txtMailingAddr.TextLength
                txtMailingAddr.SetFocus
                Exit Sub
            End If
        Else
            txtMailingAddr.Text = strTmp
            fCheckValidity = False
        End If
    End If
    
    'if document changed and recipients are required
    If (fDocChanged And (Not (rgfSkipPanel(iPANEL_RCPNTS)))) Then
        DisplayErrorMsg strERR_RCPNTS_NOT_CHOSEN
        JumpToPanel iPANEL_RCPNTS
        Exit Sub
    End If
    
    'apply style, if that fails then jump to that panel
    If Not (fNoCovSht) And Not (fStylesCopied) Then
        If Not (FCopyStyles(iFaxStyle)) Then
            JumpToPanel iPANEL_STYLE
            Exit Sub
        End If
    End If
    
    If fBalloonVisible Then
        objAssistantBalloon.Close
        'to avoid ReportError from closing balloon again
        fBalloonVisible = False
    End If
    
    If (optCovSht.Value) Then fDocIsFormLtr = False 'need to pickup names from combo boxes
    
    fCreatedCmdBar = False
    If fRestoredNow Then 'values were restored just now and no need to save
        System.PrivateProfileString("", strREG_SETTINGS_BASE_KEY, strREG_ASSISTANT_TIME_STAMP) = Format$(Now, "General Date")
        StoreValPref strREG_ASSISTANT_HELP, iLocalState
    Else
        If Not (fSettingsSaved) Then SaveDialogValues (True) 'to be done before CreateCoverSheet
    End If
    If (fNoCovSht) Then
        If (Not (fDocPresent)) Then
            formWizard.Hide
            GoTo LEndCmdFinish 'no cover sheet and no document
        End If
    Else
        CreateCoverSheet (True)
    End If
    
    If fNoCovSht Then formWizard.Hide 'bcos we display an autodown balloon after faxing.
    SetupDocForFax (True) 'if error occurs in this function, we just display an error msg.
    If (Not (fNoCovSht)) Then formWizard.Hide
LEndCmdFinish:
    Unload formWizard
    Set formWizard = Nothing
    If (fCreatedCmdBar) Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
        ActiveWindow.View.Type = wdPageView
        'display post wizard tip.
        If Not (fNoCovSht) Then
            If (iNumRcpnts > 1) Then
                DisplayPostWizTip strPOST_WIZARD_TIP_MRG_FLD, False
            Else
                DisplayPostWizTip strPOST_WIZARD_TIP_NO_MRG_FLD, False
            End If
        End If

    End If
    If lAssistantId Then Assistant.EndWizard lAssistantId, True
    If fNoCovSht Then
        'closing the active doc. might close the template too. So, do cleanup here
        ResetWizardEnvironment (True)
        ActiveDocument.Close wdDoNotSaveChanges
    End If
End Sub

Private Sub cmdOtherPrinters_Click()
    Dim objDlgPrint As Dialog
    Dim strPrinter As String, strNameFromDlg As String
    Dim iRet As Integer, i As Integer, j As Integer, k As Integer
    
    On Error GoTo FatalError
    
    Set objDlgPrint = Dialogs(wdDialogFilePrintSetup)
    'Set objDlgPrint = Dialogs(wdDialogFilePrint)
    objDlgPrint.Update
    iRet = objDlgPrint.Display
    If iRet <> 0 Then 'iRet = 0 if user clicks Cancel
        strPrinter = UCase$(objDlgPrint.Printer)
        'strip out the printer location from strPrinter. occurs after ON
        'get the last occurring ON since printer name itself can have a ON
        k = InStr(1, strPrinter, strPRINTER_ON, vbTextCompare)
        j = 0
        While (k)
            j = k
            k = InStr(k + Len(strPRINTER_ON), strPrinter, strPRINTER_ON, vbTextCompare)
        Wend
        If j > 1 Then strPrinter = Left$(strPrinter, j - 1)
        For i = 0 To iTotalNumPrinters - 1
            If strPrinter = rgstrPrinterNames(i) Then
                cboFaxDriver.ListIndex = i
                GoTo FatalError
            End If
        Next i
        If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
        rgstrPrinterNames(iTotalNumPrinters) = strPrinter
        iTotalNumPrinters = iTotalNumPrinters + 1
        cboFaxDriver.AddItem strPrinter
        cboFaxDriver.ListIndex = iTotalNumPrinters - 1
    End If
    
FatalError:
    Err.Clear
    
End Sub




'fExitTglEvent is set when we programmatically change tglAssistant's value,
'and so we don't want to call ActivateWizard once again.
Private Sub tglAssistant_Click()
    If lAssistantId = 0 Then Exit Sub 'tglAssistant should be disabled. extra safety

    If fExitTglEvent Then
        fExitTglEvent = False
        Exit Sub
    End If

    If (iLocalState = msoWizardActInactive) Then
        'we want the button to be pressed only when user chooses
        'Help with this wizard option.
        If tglAssistant.Value Then
            fExitTglEvent = True
            tglAssistant.Value = False
        End If
        Assistant.ActivateWizard lAssistantId, msoWizardActActive
    ElseIf (iLocalState = msoWizardActActive) Then
        Assistant.ActivateWizard lAssistantId, msoWizardActInactive
    End If
    
End Sub


Private Sub cmdNext_Click()
Dim i As Integer
    Select Case iCurrentPanel
        Case 1
          
        Case 3

    End Select
    i = iCurrentPanel + 1
    While (rgfSkipPanel(i) And i < iMAX_PANEL)
        i = i + 1
    Wend
    
    JumpToPanel (i)
End Sub


Private Sub cmdRcpntsAddrBk_Click()
Dim strRcpntName As String, strRcpntNum As String
Dim objCtrls As Object
Dim cboRcpntNameCtrl As ComboBox
Dim strErrMsg As String

    On Error GoTo AddrBookError
    strErrMsg = strERR_ADDR_BOOK
    
    Set objCtrls = mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    Set cboRcpntNameCtrl = objCtrls(strCBO_RCPNT_NAME & iCboRcpntNameFocus)

    strRcpntName = Application.GetAddress("", strADDR_BK_NAME_FORMAT, _
                        0, 1, 0, 1, 0, 1)
    If Len(strRcpntName) <> 0 Then
        strRcpntNum = Application.GetAddress("", strADDR_BK_FAXNUM_FORMAT, _
                        0, 2, 0, 0, 0, 0)
                        
        cboRcpntNameCtrl.Text = strRcpntName
        objCtrls(strCBO_RCPNT_NUM & iCboRcpntNameFocus).Text = strRcpntNum
        
    End If
    
ReturnAddrBk:
    cboRcpntNameCtrl.SelStart = 0
    cboRcpntNameCtrl.SelLength = Len(strRcpntName)
    Exit Sub
    
AddrBookError:
    If Err.Number Then strErrMsg = strErrMsg & vbCr & Err.Description
    DisplayErrorMsg strErrMsg
    GoTo ReturnAddrBk
    
End Sub


Private Sub cmdSenderAddrBk_Click()
Dim strRcpntName As String, strRcpntInfo As String
Dim strErrMsg As String, strChkdAddr As String
Dim i As Integer

    On Error GoTo AddrBookError
    strErrMsg = strERR_ADDR_BOOK
    strRcpntName = Application.GetAddress("", strADDR_BK_NAME_FORMAT, _
                        0, 1, 0, 1, 1, 1)
                        
    If Len(strRcpntName) <> 0 Then
        txtSenderName.Text = strRcpntName
        
        strRcpntInfo = Application.GetAddress("", strADDR_BK_ADDR_FORMAT, _
                0, 2, 0, 0, 0, 0)
        txtMailingAddr.Text = strRcpntInfo
    
        strRcpntInfo = Application.GetAddress("", strADDR_BK_COMPANY_FORMAT, 0, 2, 0, 0, 0, 0)
        txtCompany.Text = strRcpntInfo
        
        strRcpntInfo = Application.GetAddress("", strADDR_BK_PHONE_FORMAT, _
                0, 2, 0, 0, 0, 0)
        txtSenderPhone.Text = strRcpntInfo
        
        strRcpntInfo = Application.GetAddress("", strADDR_BK_FAXNUM_FORMAT, _
                0, 2, 0, 0, 0, 0)
        txtSenderFax.Text = strRcpntInfo
    End If
    
ReturnAddrBk:
    txtSenderName.SelStart = 0
    txtSenderName.SelLength = txtSenderName.TextLength
    txtSenderName.SetFocus
    Exit Sub
    
AddrBookError:
    If Err.Number Then strErrMsg = strErrMsg & vbCr & Err.Description
    DisplayErrorMsg strErrMsg
    GoTo ReturnAddrBk
    
End Sub

Private Sub imgStyleCont_Click()
    If iFaxStyle = iSTY_CONTEMPORARY Then Exit Sub
    ApplyShadowCtrl (iSTY_CONTEMPORARY)
    iFaxStyle = iSTY_CONTEMPORARY
    optStyleCont.Value = True
    optStyleCont.SetFocus
End Sub

Private Sub imgStyleEleg_Click()
    If iFaxStyle = iSTY_ELEGANT Then Exit Sub
    ApplyShadowCtrl (iSTY_ELEGANT)
    iFaxStyle = iSTY_ELEGANT
    optStyleEleg.Value = True
    optStyleEleg.SetFocus
End Sub


Private Sub imgStyleProf_Click()
    If iFaxStyle = iSTY_PROFESSIONAL Then Exit Sub
    ApplyShadowCtrl (iSTY_PROFESSIONAL)
    iFaxStyle = iSTY_PROFESSIONAL
    optStyleProf.Value = True
    optStyleProf.SetFocus
End Sub

Private Sub lblMap0_Click()
    JumpToPanel (0)
End Sub

Private Sub lblMap1_Click()
    JumpToPanel (1)
End Sub

Private Sub lblMap2_Click()
    JumpToPanel (2)
End Sub

Private Sub lblMap3_Click()
    JumpToPanel (3)
End Sub


Private Sub lblMap4_Click()
    JumpToPanel (4)
End Sub


Private Sub lblMap5_Click()
    JumpToPanel (5)
End Sub


Private Sub lblMap6_Click()
    JumpToPanel (6)
End Sub

Private Sub optCovSht_Click()
    'frmCurDoc.Enabled = False
    cboDocList.Enabled = False
    optCurDocCovShtYes.Enabled = False
    optCurDocCovShtNo.Enabled = False
    fNoCovSht = False
    EnablePanel (iPANEL_SENDER)
    EnablePanel (iPANEL_STYLE)
    EnablePanel (iPANEL_RCPNTS)
    'if combo-boxes have not been initialized
    If (Not (fRegistryNamesRead)) Then ReadRegistryFaxNames (True)
    'reset recipients panel to ord. doc panel
    If (fDocIsFormLtr) Then 'else already ord. doc panel
        formWizard.frmRcpntsFormDoc.Visible = False
        formWizard.frmRcpntsOrdDoc.Visible = True
        fDocChanged = True
    End If
End Sub


Private Sub optCurDoc_Click()
    cboDocList.Enabled = True
    optCurDocCovShtYes.Enabled = True
    optCurDocCovShtNo.Enabled = True
    If (optCurDocCovShtNo.Value) Then
        fNoCovSht = True
        DisablePanel (iPANEL_SENDER)
        DisablePanel (iPANEL_STYLE)
        If (iFaxOption <> iMS_FAX) Then DisablePanel (iPANEL_RCPNTS)
    End If
    If (fDocIsFormLtr) Then 'just cover sheet option might have changed this
        formWizard.frmRcpntsFormDoc.Visible = True
        formWizard.frmRcpntsOrdDoc.Visible = False
        fDocChanged = True
    End If
End Sub


Private Sub optCurDocCovShtNo_Click()
    fNoCovSht = True
    DisablePanel (iPANEL_SENDER)
    DisablePanel (iPANEL_STYLE)
    If (iFaxOption <> iMS_FAX) Then DisablePanel (iPANEL_RCPNTS)
End Sub


Private Sub optCurDocCovShtYes_Click()
    fNoCovSht = False
    EnablePanel (iPANEL_SENDER)
    EnablePanel (iPANEL_STYLE)
    EnablePanel (iPANEL_RCPNTS)
End Sub


Private Sub optDataSrcSelect_Click()
    Dim objDlgQryOptions As Dialog
    Dim objTempDoc As Document
    Dim strErrMsg As String
    On Error GoTo FatalError
    
    strErrMsg = strERR_DISPLAY_QUERY_OPTIONS
    'bring up mail merge query dialog. You need a form letter as the main doc.
    Set objTempDoc = ActiveDocument
    Application.ScreenUpdating = False
    objMainDoc.Activate

    Set objDlgQryOptions = Dialogs(wdDialogMailMergeQueryOptions)
    If (objDlgQryOptions.Show) Then 'user didn't cancel out
        strFormLetterSQL = objDlgQryOptions.SQLStatement
        strFormLetterSQL1 = objDlgQryOptions.SQLStatement1
    Else
        optDataSrcAll.Value = True
        optDataSrcAll.SetFocus
    End If
ActivateNewDoc:
    objTempDoc.Activate
    Application.ScreenUpdating = True
    Exit Sub
FatalError:
    If Err.Number Then strErrMsg = strErrMsg & vbCr & Err.Description
    DisplayErrorMsg strErrMsg
    optDataSrcAll.Value = True
    optDataSrcAll.SetFocus
    GoTo ActivateNewDoc
End Sub


Private Sub optDifferentFax_Click()
    lblFaxDriver.Enabled = True
    cboFaxDriver.Enabled = True
    cmdOtherPrinters.Enabled = True
    iFaxOption = iDIFF_FAX
    If (fNoCovSht) Then DisablePanel (iPANEL_RCPNTS) 'Panel 4 & 5 already would have been
                                                     'disabled when user selected "No Fax"
End Sub


Private Sub optMSFax_Click()
    lblFaxDriver.Enabled = False
    cboFaxDriver.Enabled = False
    cmdOtherPrinters.Enabled = False
    iFaxOption = iMS_FAX
    EnablePanel (iPANEL_RCPNTS)
End Sub


Private Sub optNoFax_Click()
    lblFaxDriver.Enabled = False
    cboFaxDriver.Enabled = False
    cmdOtherPrinters.Enabled = False
    iFaxOption = iNO_FAX
    If (fNoCovSht) Then DisablePanel (iPANEL_RCPNTS) 'Panel 4 & 5 already would have been
                                                     'disabled when user selected "No Fax"
End Sub


Private Sub optStyleCont_Click()
    ApplyShadowCtrl (iSTY_CONTEMPORARY)
    iFaxStyle = iSTY_CONTEMPORARY
    fStylesCopied = False
End Sub


Private Sub optStyleEleg_Click()
    ApplyShadowCtrl (iSTY_ELEGANT)
    iFaxStyle = iSTY_ELEGANT
    fStylesCopied = False
End Sub


Private Sub optStyleProf_Click()
    ApplyShadowCtrl (iSTY_PROFESSIONAL)
    iFaxStyle = iSTY_PROFESSIONAL
    fStylesCopied = False
End Sub

Private Sub shpMap0_Click()
    JumpToPanel (0)
End Sub
Private Sub shpMap1_Click()
    JumpToPanel (1)
End Sub

Private Sub shpMap2_Click()
    JumpToPanel (2)
End Sub

Private Sub shpMap3_Click()
    JumpToPanel (3)
End Sub

Private Sub shpMap4_Click()
    JumpToPanel (4)
End Sub

Private Sub shpMap5_Click()
    JumpToPanel (5)
End Sub


Private Sub shpMap6_Click()
    JumpToPanel (6)
    
End Sub


'jumps to iNewPanel in the dialog
Private Sub JumpToPanel(iNewPanel As Integer)
Dim objFormCtrls As Object
Dim lNewFormTop As Long, lNewFormLeft As Long

    If ((iCurrentPanel = iNewPanel) Or (rgfSkipPanel(iNewPanel))) Then Exit Sub
    
    If FPageLostFocus Then
        Set objFormCtrls = formWizard.Controls
        ' Deselect current flow chart marker
        objFormCtrls(strSHP_MAP & iCurrentPanel).BackColor = COLOR_DARKGREY
        objFormCtrls(strLBL_MAP & iCurrentPanel).FONTBOLD = False
        iCurrentPanel = iNewPanel
            
        ' Select new flow chart marker
        objFormCtrls(strSHP_MAP & iCurrentPanel).BackColor = COLOR_GREEN
        objFormCtrls(strLBL_MAP & iCurrentPanel).FONTBOLD = True
            
        ' Change to new active page
        formWizard.mpgWizardPage.Value = iCurrentPanel
        If fBalloonVisible Then
            lNewFormTop = formWizard.Top
            lNewFormLeft = formWizard.Left
            
            If (lNewFormTop <> lFormTop) Or (lNewFormLeft <> lFormLeft) Then
                lFormTop = lNewFormTop
                lFormLeft = lNewFormLeft
                objAssistantBalloon.SetAvoidRectangle lFormLeft, lFormTop, lFormLeft + lFormWidth, lFormTop + lFormHeight
            End If
            objAssistantBalloon.Close
            objAssistantBalloon.Text = rgstrAssistantMsg(iNewPanel)
            objAssistantBalloon.Show
        End If
        PageSetFocus
    End If
End Sub

'misc. stuff to do, when the panel is displayed
Private Sub PageSetFocus()
    Select Case iCurrentPanel
        Case 0
            cmdNext.SetFocus
            cmdBack.Enabled = False
            
        Case 1
            If optCurDoc.Value Then
                optCurDoc.SetFocus
            Else
                optCovSht.SetFocus
            End If
        Case 2
            Select Case iFaxOption
                Case iMS_FAX
                    optMSFax.SetFocus
                Case iDIFF_FAX
                    optDifferentFax.SetFocus
                Case iNO_FAX
                    optNoFax.SetFocus
            End Select
            
        Case iPANEL_RCPNTS
            fDocChanged = False
            If (fDocIsFormLtr) And (optCurDoc.Value) Then
                '1st control is the combo-box containing fields for recipient's first name
                cboFldsRcpntFirstName.SelStart = 0
                cboFldsRcpntFirstName.SelLength = cboFldsRcpntFirstName.TextLength
                cboFldsRcpntFirstName.SetFocus
            Else 'if reg. doc or only cover sheet
                '1st control is the combo-box for recipient name
                cboRcpntName0.SelStart = 0
                cboRcpntName0.SelLength = cboRcpntName0.TextLength
                cboRcpntName0.SetFocus
            End If
        
        Case iPANEL_SENDER 'Sender info panel
            txtSenderName.SelStart = 0
            txtSenderName.SelLength = txtSenderName.TextLength
            txtSenderName.SetFocus
            
        Case iPANEL_STYLE 'coversheet style
            Select Case iFaxStyle
                Case iSTY_PROFESSIONAL
                    optStyleProf.SetFocus
                Case iSTY_CONTEMPORARY
                    optStyleCont.SetFocus
                Case iSTY_ELEGANT
                    optStyleEleg.SetFocus
            End Select
                    
        
        Case iMAX_PANEL
            If (fNoCovSht) And (iFaxOption <> iNO_FAX) Then
                lblFinishText.Caption = strLAST_PANEL_NOCOVSHT_TEXT
            Else
                lblFinishText.Caption = strLAST_PANEL_DFLT_TEXT
            End If
            cmdFinish.SetFocus
            cmdNext.Enabled = False
            If Not (fSettingsSaved) Then SaveDialogValues (True)
    End Select
End Sub

'misc. stuff to be done when a panel is being replaced
'by another one.
Private Function FPageLostFocus()
Dim strTmp As String, strNewText As String
Dim fRet As Boolean

    fRet = True
    Select Case iCurrentPanel
        Case 0
            cmdBack.Enabled = True
            If Not (fSettingsRestored) Then
                SetMainDoc (True)
                RestoreDialogValues (True)
            End If
        Case iPANEL_SENDER
            If fCheckValidity Then
                strTmp = StrRemoveCrLfFromEnd(txtMailingAddr.Text)
                If ICountLines(strTmp, strNewText, iMAX_ADDR_LINES) > iMAX_ADDR_LINES Then
                    DisplayErrorMsg (strERR_MAX_ADDR_LINES)
                    txtMailingAddr.SelStart = 0
                    txtMailingAddr.SelLength = txtMailingAddr.TextLength
                    txtMailingAddr.SetFocus
                    FPageLostFocus = False
                    Exit Function
                End If
            Else
                txtMailingAddr.Text = strTmp
                fCheckValidity = False
            End If
        Case iPANEL_STYLE
            If Not (fStylesCopied) Then
                If Not (FCopyStyles(iFaxStyle)) Then fRet = False
            End If
        Case iMAX_PANEL
            fSettingsSaved = False
            cmdNext.Enabled = True
    End Select

    FPageLostFocus = fRet
End Function

'sets flags so that panel is not displayed
Private Sub DisablePanel(iPanel As Integer)
Dim objFormCtrls As Object

    If rgfSkipPanel(iPanel) Then Exit Sub 'already disabled
    
    Set objFormCtrls = formWizard.Controls
    
    rgfSkipPanel(iPanel) = True
    rgiColorShape(iPanel) = objFormCtrls(strSHP_MAP & iPanel).BackColor
    objFormCtrls(strLBL_MAP & iPanel).ForeColor = COLOR_DISABLED
    objFormCtrls(strSHP_MAP & iPanel).BackColor = COLOR_DISABLED
    
End Sub

Private Sub EnablePanel(iPanel As Integer)
Dim objFormCtrls As Object

    If Not (rgfSkipPanel(iPanel)) Then Exit Sub 'already enabled
    
    Set objFormCtrls = formWizard.Controls
    
    rgfSkipPanel(iPanel) = False
    objFormCtrls(strLBL_MAP & iPanel).ForeColor = COLOR_WHITE
    objFormCtrls(strSHP_MAP & iPanel).BackColor = rgiColorShape(iPanel)
End Sub


Private Sub ApplyShadowCtrl(iStyle As Integer)

    If iFaxStyle = iStyle Then Exit Sub
    
    Select Case iFaxStyle
        Case iSTY_PROFESSIONAL
            lblStyle0.Visible = False
        Case iSTY_CONTEMPORARY
            lblStyle1.Visible = False
        Case iSTY_ELEGANT
            lblStyle2.Visible = False
    End Select
    
    Select Case iStyle
        Case iSTY_PROFESSIONAL
            lblStyle0.Visible = True
        Case iSTY_CONTEMPORARY
            lblStyle1.Visible = True
        Case iSTY_ELEGANT
            lblStyle2.Visible = True
    End Select
End Sub

Private Sub txtMailingAddr_Change()
    fCheckValidity = True
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If (CloseMode = vbFormControlMenu) Then
        Err.Clear
        ReportError Err
    End If
End Sub



' InQuest injected base64 decoded content
' Szjej

INQUEST-PP=macro
